В процессе создания исполняемого файла должны быть разрешены ссылки на библиотечные функции. Существует два 
метода разрешения таких ссылок: статическая компоновка
и динамическая компоновка. Какой из них выбрать, определяется аргументами командной строки компоновщика. Любой 
исполняемый файл может быть скомпонован статически, динамически или обоими способами1
.
Если запрашивается статическая компоновка, то компоновщик объединяет объектные файлы приложения с копией затребованной библиотеки и таким образом создает исполняемый 
файл. Во время выполнения нет необходимости искать библиотечный код, потому что он уже содержится внутри исполняемого 
файла. Статическая компоновка имеет следующие преимущества: (1) функции вызываются чуть быстрее и (2) распространение 
двоичных файлов проще, потому что не делается никаких предположений о доступности библиотечного кода в системе пользователя. Но у нее есть и недостатки: (1) размер исполняемого 
файла увеличивается и (2) сложнее переходить на новую версию 
программы, когда изменяются библиотеки. Последнее связано 
с тем, что программу нужно пересобирать всякий раз, как изменяется какая-нибудь библиотека. С точки зрения обратной разработки, статическая компоновка несколько усложняет задачу. 
Анализируя статически скомпонованный файл, мы не можем 
так просто ответить на вопросы типа «С какими библиотеками 
скомпонован файл?» и «Какие из имеющихся функций взяты из 
библиотеки?». В главе 13 обсуждаются проблемы обратной разработки статически скомпонованных файлов.
Динамическая компоновка отличается от статической тем, 
что компоновщику не нужно копировать затребованные библиотеки. Вместо этого он вставляет только ссылки на эти библиотеки (часто файлы с расширением .so или .dll) в окончательный исполняемый файл, поэтому размер конечного файл

обычно оказывается гораздо меньше. Обновление библиотечного кода тоже существенно упрощается. Поскольку существует всего одна копия библиотеки, на которую ссылается много двоичных файлов, простая замена старой версии библиотеки новой приводит к тому, что все динамически скомпонованные с ней файлы автоматически начинают пользоваться новой версией. К недостаткам динамической компоновки можно отнести более сложный процесс загрузки. Все необходимые библиотеки должны быть найдены и загружены в память, тогда как в случае статической компоновки нужно загрузить только один файл, который уже содержит весь библиотечный код. Еще один недостаток динамической компоновки – необходимость включать в дистрибутив не только собственный исполняемый файл, но и все библиотеки, от которых этот файл зависит. Попытка выполнить программу в системе, где нет необходимых библиотек, приведет к ошибке. Ниже демонстрируется создание динамически и статически скомпонованных версий программы, размер получающихся двоичных файлов и то, как их идентифицирует утилита file

Для правильной работы динамически скомпонованный файл должен содержать информацию о том, от каких библиотек он зависит, и о том, что нужно взять из каждой библиотеки. Поэтому, в отличие от статически скомпонованных файлов, определить, от каких библиотек зависит динамически скомпонованный файл, очень просто. Утилита ldd (list dynamic dependencies – перечислить динамические зависимости) выводит список динамических библиотек, необходимы

Утилита ldd входит в состав систем Linux и BSD. В системах macOS аналогичную функциональность предлагает утилита otool с флагом -L: otool -L filename. В Windows для вывода списка зависимых библиотек служит утилита dumpbin, входящая в состав Visual Studio: dumpbin /dependents filename