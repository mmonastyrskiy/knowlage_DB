языки, допускающие перегрузку функций, должны предоставлять механизм различения перегруженных вариантов функции, потому что все они имеют одно и то же имя. В следующем примере, написанном на C++, показаны прототипы нескольких перегруженных вариантов функции
Вообще говоря, в одном объектном файле не может быть двух функций с одинаковым именем. Чтобы сделать перегрузку возможной, компиляторы генерируют уникальные имена, включая информацию о типах аргументов функции. Процедура ния уникальных имен функций с одинаковым именем называется декорированием имени (name mangling)1 . Воспользовавшись nm для вывода символов в откомпилированной версии показанного выше кода на C++, мы можем увидеть нечто подобное (вывод профильтрован, чтобы не отвлекаться ни на что, кроме demo
Стандарт C++ не определяет схему декорирования имен, оставляя это на усмотрение разработчиков компиляторов. Чтобы декодировать различные варианты demo, нужен инструмент, который понимает схему декорирования имен, принятую в нашем компиляторе (в данном случае g++). Именно в этом и состоит назначение утилиты c++filt, которая рассматривает каждое входное слово, как будто это декорированное имя, и пытается определить, какой компилятор его сгенерировал. Если строка выглядит как правильно декорированное имя, то на выходе печатается его декодированный вариант. Если же c++filt не может интерпретировать строку, то просто выводит ее без изменения. Если пропустить результаты nm из предыдущего примера через c++filt, то будут восстановлены декорированные имена функций

Важно отметить, что декорированные имена несут дополнительную информацию о функциях, которую nm обычно не предоставляет. Эта информация может быть очень полезна для обратной разработки и в более сложных случаях может включать данные об именах классов или соглашениях о вызове функций.