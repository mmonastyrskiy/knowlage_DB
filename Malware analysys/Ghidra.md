Тулза предназначенная для обратной инженерии программного обеспечения входит в стандартный пакет программ [[Remnux]]

Конспект основан на прочитанной книге: [[Книги#Игл, Нэнс Ghidra. Полное руководство]]
В книге приводится список инструментов которые в некоторой степени могут заменить Ghidra в области анализа файлов: [[Инструменты анализа файлов]]



### РЕСУРСЫ ПОДДЕРЖКИ GHIDRA 
Работа с новой программой часто пугает, особенно когда требуется решить трудную реальную проблему с помощью обратной разработки. Как пользователю (или потенциальному разработчику) Ghidra вам наверняка интересно, куда обратиться за помощью, если возникнут вопросы. Если мы хорошо справились со своей работой, то во многих ситуациях  этой книги будет достаточно. Но на случай, если вам понадобится дополнительная помощь, подскажем, какие имеются ресурсы. Официальная документация. Ghidra содержит подробную справочную систему, в которую можно попасть из меню или нажатием клавиши F1. Система предлагает иерархическое меню, а также средства поиска. Но в настоящее время не поддерживаются запросы в свободной форме типа «Как сделать x?». Файлы readme. Иногда меню Help отсылает к дополнительному материалу по теме, например файлу readme. В документацию включено много таких файлов, которые сопровождают плагины, дополняют материал, представленный в меню Help (например, support / analyzeHeadlessREADME.html), помогают выполнять установку (docs /InstallationGuide.html) и служат подспорьем разработчику (например, Extensions/Eclipse/GhidraDev/ GhidraDev_README.html), если вы решите пойти по этому пути (и, чем черт не шутит, написать поддержку вопросов в свободной форме). Сайт Ghidra. На домашней странице проекта Ghidra (https://www.ghidra-sre.org/) имеются предложения для потенциальных пользователей, текущих пользователей, разработчиков и соавторов, помогающие каждой категории расширить свои знания о Ghidra. Помимо подробной информации о скачивании каждого выпуска Ghidra, выложено полезное видео, описывающее процедуру установки по шагам. Каталог docs. В состав установки Ghidra входит каталог, содержащий полезную документацию, в т. ч. допускающее распечатку руководство по меню и горячим клавишам (docs/CheatSheet.html), которое здорово поможет при первом знакомстве с Ghidra, а также много другое. В каталоге docs/GhidraClass вы найдете пособия для пользователей Ghidra начального, среднего и продвинутого уровней




### СКАЧИВАНИЕ GHIDRA
Для получения копии Ghidra нужно сделать три простых шага. 1. Перейдите на сайт https://ghidra-sre.org/. 2. Нажмите большую красную кнопку Download Ghidra. 3. Сохраните файл на своем компьютере. Как часто бывает с простыми трехшаговыми процессами, есть пара мест, где упрямый ослушник может предпочесть немного отклониться от рекомендованного пути. Следующие пункты адресованы тем из вас, кто хочет чего-нибудь, отличного от традиционного меню. ► Если вы хотите установить другую версию, просто нажмите кнопку Releases – и вам будет предложено скачать другие выпускные версии. В каких-то моментах функциональность может отличаться, но в основе своей это все та же Ghidra. ► Если вы хотите установить сервер для коллективной работы, подождите до главы 11, где описано, как внести это важное изменение в процедуру установки (или на свой страх и риск попробуйте воспользоваться информацией в каталоге server). В худшем случае будет несложно откатиться назад, начать с первого шага и установить локальный экземпляр Ghidra. ► Сильные духом могут попробовать собрать Ghidra из исходников. Исходный код Ghidra имеется на GitHub по адресу https://github.com/NationalSecurityAgency/ghidra/. А мы продолжим рассказ о традиционном процессе установки

### УСТАНОВКА GHIDRA
Итак, что произошло, когда вы нажали волшебную красную кнопку и выбрали место на своем компьютере? Если все пройдет по плану, то в выбранном каталоге должен появиться zip-файл. Для самой первой версии Ghidra файл назывался ghidra_9.0_PUBLIC_20190228.zip. Zip-файл представляет собой архив, содержащий больше 3400 файлов, составляющих каркас Ghidra. Если вас устраивает место, куда был сохранен файл, распакуйте его (например, в Windows щелкните по нему правой кнопкой мыши и выберите из контекстного меню пункт Извлечь все), и вы получите доступ к иерархии каталогов Ghidra. Отметим, что Ghidra должна откомпилировать кое-какие внутренние файлы данных, поэтому пользователю понадобится доступ к подкаталогам с правом записи.

### Структура каталогов Ghidra
Близкое знакомство с содержимым установочного каталога Ghidra необязательно – начать работать можно и так. Но уж коль скоро мы заговорили о распаковке дистрибутива, кинем взгляд на структуру каталогов. Эти знания пригодятся позже, когда мы перейдем к продвинутым средствам Ghidra. Ниже приведено краткое описание всех подкаталогов, а на рис. 3.1 показан их перечень. Рис. 3.1. Структура каталогов Ghidra docs. Содержит общую документацию по Ghidra и работе с ней. Внутри этого каталога есть два достойных упоминания подкаталога. Во-первых, в подкаталоге GhidraClass находятся дополнительные учебные материалы, которые помогут вам больше узнать о Ghidra. Во-вторых, в подкаталоге languages описывается язык спецификации процессоров SLEIGH. Мы будем подробно обсуждать его в главе 18. ПервОе знакОмство с Ghidra 69 Extensions. Содержит полезные уже собранные расширения, а также данные и информацию, важную для написания расширений Ghidra. Этот каталог подробно рассматривается в главах 15, 17 и 18. Ghidra. Содержит код Ghidra. О том, что здесь находится, мы подробно расскажем, когда начнем настраивать Ghidra в главе 12 и расширять ее возможности в главах 13–18. GPL. Некоторые компоненты были разработаны не командой Ghidra, но включают код, распространяемый по лицензии GNU General Public License (GPL). В каталоге GPL находятся относящиеся к таким компонентам файлы, а также информация о лицензии. licenses. Содержит файлы, описывающие юридические условия использования сторонних компонент Ghidra. server. Поддержка установки сервера Ghidra, необходимо для коллективной работы над SRE. Этот каталог подробно обсуждается в главе 11. support. Сборная солянка – различные специальные возможности и средства Ghidra. В качестве бонуса прилагается значок Ghidra (ghidra.ico), если вы захотите продолжить настройку своей среды (например, создать ярлык, указывающий на скрипт запуска Ghidra). Этот каталог будет обсуждаться по мере необходимости в разных частях книги

### Запуск Ghidra 
Наряду с каталогами, в корневом каталоге есть файлы, которые помогут начать путешествие в мир Ghidra и SRE. Здесь имеется еще один файл лицензии (LICENSE.txt), но главное – скрипты запуска Ghidra. После первого двойного щелчка по файлу ghidraRun.bat (или его эквивалента ghidraRun в Linux или macOS) нужно будет принять лицензионное соглашение с конечным пользователем (EULA), показанное на рис. 3.2, подтвердив тем самым, что планируемое использование Ghidra не противоречит соглашению с пользователем (Ghidra User Agreement). При последующих запусках это окно уже не будет показываться, но его всегда можно вызвать из меню Help. 70 ГЛАВА 3 Кроме того, может быть задан вопрос о пути к установке Java. (Если на вашем компьютере Java не установлен, см. «Руководство по установке» в подкаталоге docs, где имеется необходимая документация в разделе «Java Notes».) Для Ghidra необходима версия Java Development Kit (JDK) 11 или старше


Идентификация компилятора Идентифицировать компилятор, который собирал программу, полезно, потому что это помогает понять соглашения о вызове и установить, с какими библиотеками мог быть скомпонован двоичный файл. Если удается идентифицировать компилятор в процессе загрузки, то автоматический анализ учтет знания о его специфике. Различия, наблюдаемые при использовании разных компиляторов и режимов компиляции, обсуждаются в главе 20. Идентификация аргументов функции и локальных переменных Для каждой идентифицированной функции (это делается на основе таблицы символов и адресов в командах вызова) Ghidra выполняет детальный анализ поведения регистра указателя стека, чтобы, во-первых, распознать доступ к переменным в стеке, а во-вторых, понять структуру кадра стека данной функции. Имена таких переменных генерируются автоматически с учетом их использования: в качестве локальных переменных или размещенных в стеке аргументов, переданных функции при вызове. Кадры стека рассматриваются в главе 6. Информация о типах данных Ghidra использует знание о хорошо известных библиотечных функциях и их параметрах для идентификации функций, ти88 ГЛАВА 4 пов данных и структур данных, используемых внутри каждой функции. Эта информация добавляется в окна дерева символов, диспетчера типов данных и листинга. Данный процесс экономит вам кучу времени, сообщая информацию, которую иначе пришлось бы собирать вручную из различных справочников по интерфейсам прикладного программирования (API). О том, как Ghidra обращается с библиотечными функциями и их типами данных, мы подробно поговорим в главе 8

### СОВЕТЫ ПО ОРГАНИЗАЦИИ РАБОЧЕГО СТОЛА GHIDRA
Ghidra отображает огромный объем информации, так что ее рабочий стол со временем загромождается. Ниже приведено несколько советов, как лучше пользоваться своим рабочим столом. ► Чем больше места на экране отведено Ghidra, тем удобнее с ней работать. Это может служить оправданием для покупки гигантского монитора (или сразу четырех)! ► Не забывайте использовать меню Window (Окно) в браузере кода для открытия новых представлений или восстановления случайно закрытых окон данных. Многие окна можно также открыть с помощью значков на панели инструментов браузера кода. ► Вновь открытое окно может заслонить какое-то из существующих. В таком случае поищите вкладки в нижнем или верхнем окне, позволяющие переключаться между ними. ► Можно закрыть любое окно, а затем снова открыть, когда оно понадобится, и перетащить в другое место рабочего стола. ► Внешним видом окон можно управлять с помощью параметров отображения в окне, открываемом командой EditTool Options (Редактирование Параметры инструментов). Эти советы – не более чем верхушка айсберга, но и они пригодятся, когда вы начнете разбираться в рабочем столе браузера кода. Дополнительные рекомендации и хитрости, включая горячие клавиши и панель инструментов, обсуждаются в главе 5.

### Граф в Ghidra
В режиме графа отображается только одна функция. Ghidra реализует навигацию по графу, применяя традиционные методы взаимодействия с изображениями, в частности панорамирование и изменение масштаба. Для большой и сложной функции граф может оказаться очень громоздким, так что по нему будет трудно перемещаться. В этом случае поможет вид со спутника. По умолчанию представление «вид со спутника» находится в правом нижнем углу окна графа и бывает очень полезно, когда нужно оценить ситуацию в целом (см. рис. 5.9). Спутниковая навигация На виде со спутника всегда отображается полная блочная структура графа, а подсвечен блок, соответствующий области графа, которая сейчас просматривается в окне дизассемблера. Если щелкнуть по любому блоку на виде со спутника, то граф будет перерисован так, чтобы этот блок оказался в его центре. Подсвеченный блок играет роль объектива, который можно буксировать по окну, чтобы быстро переместиться в любое место графа. Помимо средства для навигации по графу функции, это магическое окно обладает и другими возможностями, которые иногда помогают, а иногда мешают исследованию файла. Это окно занимает ценное место в окне графа функции и может загораживать важные вещи именно тогда, когда вы хотите на них взглянуть. Разрешить проблему можно двумя способами. Можно щелкнуть по виду со спутника и сбросить флажок Dock Satellite View (Пристыковать вид со спутника). Тогда вид со спутника со всей его функциональностью окажется за пределами окна графа функции. Если впоследствии снова установить флажок, то вид со спутника вернется на свое обычное место. Второй способ – скрыть вид со спутника, если вы не хотите пользоваться им для навигации. Для этого служит другой флажок в контекстном меню. Если вид со спутника скрыт, то в правом нижнем углу окна графа функции появится небольшой значок, щелчок по которому восстанавливает вид со спутника. Если вид со спутника присутствует на экране, то основное представление может работать медленнее, чем хотелось бы. Скрыв этот вид, мы сделаем его более отзывчивым.
### Навигация в дизассемблере
![[Pasted image 20240131201846.png]]

### Соглашения о вызове функции 

Соглашения о вызове Вызывающая функция должна сохранить передаваемые аргументы именно там, где вызываемая ожидает их найти, иначе возникнут серьезные проблемы. Соглашение о вызове точно определяет, где сохранять аргументы вызываемой функции: в конкретных регистрах, в стеке программы или и в регистрах, и в стеке. Если аргументы передаются в стеке, то соглашение о вызове также определяет, кто должен удалить их из стека по завершении вызванной функции: вызывающая или вызываемая сторона. Для какой бы архитектуры вы ни реконструировали программу, понять код, окружающий вызов функции, будет трудно, если не знать, какие действуют соглашения о вызове. В следующих разделах мы рассмотрим некоторые общеупотребительные соглашения, встречающиеся в откомпилированном коде на C и C++. Передача аргументов в регистрах и в стеке Аргументы функции можно передавать в регистрах процессора, в стеке программы или там и там. Если аргументы помещаются в стек, то вызывающая сторона выполняет команду записи в память (обычно PUSH), а вызываемая должна прочитать аргументы из памяти. Чтобы ускорить процесс вызова функции, иногда соглашения о вызове допускают передачу аргументов в регистрах. Если аргумент передается в регистре, то отпадает необходимость в операциях чтения и записи в память, поскольку аргумент доступен вызываемой функции непосредственно. Недостатком такой схемы является тот факт, что количество регистров процессора ограничено, тогда как списки аргументов функции могут быть сколь угодно велики, поэтому соглашение должно учитывать случай, когда аргументов больше, чем доступных регистров. «Лишние» аргументы, для которых не хватило регистров, обычно размещаются в стеке. Соглашение о вызове C Соглашение о вызове C применяется по умолчанию в большинстве компиляторов C при генерировании кода вызова функций. Чтобы явно описать это соглашение в программе на C/C++, можно включить в прототип функции ключевое слово _cdecl. Соглашение cdecl требует, чтобы вызывающая сторона помещала аргументы 144 ГЛАВА 6 в стек в порядке справа налево и чтобы она же (а не вызываемая сторона) удаляла их из стека после завершения вызванной функции. На 32-разрядной платформе x86 соглашение cdecl требует, чтобы все аргументы передавались в стеке. На 64-разрядной платформе x86 cdeclзависит от операционной системы; в Linux первые шесть (или менее) аргументов помещаются в регистры RDI, RSI, RDX, RCX, R8 и R9, именно в таком порядке, а остальные передаются в стеке. На платформе ARM первые четыре аргумента передаются в регистрах R0–R3, а начиная с пятого – в стеке. Если передаваемые в стеке аргументы помещаются в стек в порядке справа налево, то самый левый аргумент всегда находится на вершине стека. Это позволяет легко найти первый аргумент вне зависимости от общего числа ожидаемых функцией аргументов, поэтому соглашение о вызове cdecl идеально подходит для функций с переменным числом аргументов (например, printf). Требование о том, чтобы вызывающая функция удаляла параметры из стека, означает, что вы часто будете видеть команды, которые корректируют указатель стека сразу после возврата из вызванной функции. В случае функций, принимающих переменное число аргументов, именно вызывающая сторона точно знает, сколько аргументов было передано, и может правильно выполнить корректировку, тогда как вызванная функция заранее не знает, сколько аргументов получит. В следующих примерах рассматриваются вызовы функций на 32-разрядной платформе x86 с разными соглашениями о вызове. Первая функция имеет такой прототип: void demo_cdecl(int w, int x, int y, int z); По умолчанию в этой функции используется соглашение о вызове cdecl, т. е. она ожидает, что все четыре параметра будут переданы в стеке в порядке справа налево и вызывающая сторона очистит стек после возврата. Для следующего вызова функции на C: demo_cdecl(1, 2, 3, 4); // вызов demo_cdecl (на C) компилятор может сгенерировать такой код: ДизассемБлирОвание в Ghidra 145  PUSH 4 ; поместить в стек параметр z PUSH 3 ; поместить в стек параметр y PUSH 2 ; поместить в стек параметр x PUSH 1 ; поместить в стек параметр w CALL demo_cdecl; вызвать функцию  ADD ESP, 16 ; восстановить прежнее значение ESP Четыре операции PUSH  увеличивают указатель стека (ESP) на 16 байт (4 * sizeof(int) в 32-разрядной архитектуре), и это изменение аннулируется сразу после возврата из demo_cdecl . Показанная ниже техника, которая использовалась в некоторых версиях компиляторов GNU (gcc и g++), также согласуется с соглашением о вызове cdecl, но устраняет необходимость явно удалять параметры из стека после каждого обращения к demo_cdecl: MOV [ESP+12], 4 ; поместить параметр z в четвертую позицию в стеке MOV [ESP+8], 3 ; поместить параметр y в третью позицию в стеке MOV [ESP+4], 2 ; поместить параметр x во вторую позицию в стеке MOV [ESP], 1 ; поместить параметр w в первую позицию в стеке CALL demo_cdecl ; вызвать функцию В этом примере помещение параметров demo_cdecl в стек не изменяет значения указателя стека. Заметим также, что при вызове функции таким способом указатель стека указывает на самый левый аргумент в стеке. Стандартное соглашение о вызове В 32-разрядных DLL для Windows компания Microsoft часто использует так называемое стандартное соглашение о вызове. В исходном коде оно описывается модификатором _stdcall в объявлении функции: void _stdcall demo_stdcall(int w, int x, int y); Чтобы избежать путаницы, связанной с употреблением слова стандартный, мы далее будем называть это соглашение просто stdcall. 146 ГЛАВА 6 Соглашение stdcall также требует, чтобы все размещаемые в стеке параметры функций помещались туда в порядке справа налево, но за удаление параметров из стека отвечает вызванная функция. Это возможно только для функций, принимающих фиксированное количество параметров; функции с переменным числом аргументов, например printf, не могут пользоваться соглашением о вызове stdcall. Функция demo_stdcall принимает три целых аргумента, занимающих 12 байт в стеке (3 * sizeof(int) в 32-разрядной архитектуре). Компилятор на платформе x86 может воспользоваться специальной формой команды RET, которая одновременно извлекает из стека адрес возврата и увеличивает указатель стека, чтобы очистить стек от аргументов функции. В случае demo_stdcall мы могли бы увидеть такую команду возврата: RET 12 ; вернуться и удалить из стека 12 байт Использование соглашения stdcall избавляет от необходимости очищать стек после каждого вызова функции, что делает программы чуть меньше и чуть быстрее. Microsoft применяет это соглашение для всех функций с фиксированным числом аргументов, экспортируемых из 32-разрядных разделяемых библиотек (DLL-файлов). Об этом важно помнить при попытке сгенерировать прототипы функций или двоично совместимые замены разделяемых библиотек. Соглашение fastcall на платформе x86 Компиляторы Microsoft C/C++ и GNU gcc/g++ (начиная с версии 3.4) понимают соглашение fastcall – вариант соглашения stdcall, при котором первые два аргумента помещаются в регистры ECX и EDX соответственно. Все остальные аргументы помещаются в стек в порядке справа налево, и за удаление их из стека при возврате отвечает вызванная функция. В следующем объявлении демонстрируется использование модификатора fastcall: void fastcall demo_fastcall(int w, int x, int y, int z); ДизассемБлирОвание в Ghidra 147 Для следующей функции, написанной на C: demo_fastcall(1, 2, 3, 4); // вызов demo_fastcall (на C) компилятор мог бы сгенерировать такой код: PUSH 4 ; поместить параметр z во вторую позицию в стеке PUSH 3 ; поместить параметр y на вершину стека MOV EDX, 2 ; поместить параметр x в EDX MOV ECX, 1 ; поместить параметр w в ECX Call demo_fastcall ; вызвать функцию После возврата из функции demo_fastcall очистка стека не нужна, потому что она сама отвечает за удаление параметров y и z из стека. Важно понимать, что поскольку два аргумента передаются в регистрах, вызываемая функция должна очистить только 8 байт в стеке, хотя ей и передано четыре аргумента. Соглашения о вызове C++ Нестатические функции-члены классов C++ должны получать указатель на объект, от имени которого была вызвана функция (указатель this) 1 . Адрес этого объекта должен быть передан вызывающей стороной в качестве параметра, но в стандарте языка C++ не описано, как именно должен передаваться этот указатель this, поэтому неудивительно, что в разных компиляторах это делается по-разному. На платформе x86 компилятор Microsoft C++ применяет соглашение о вызове thiscall, согласно которому this передается в регистре ECX/RCX, а нестатическая функция-член должна чистить стек от параметров, как в соглашении stdcall. Компилятор GNU g++ считает this неявным первым параметром нестатической функции-члена и ведет себя точно так же, как при использовании соглашения cdecl. Таким образом, в 32-раз1 В классе C++ могут быть определены функции-члены двух видов: статические и нестатические. Нестатические функции-члены используются для манипулирования атрибутами конкретных объектов и потому должны точно знать, с каким объектом работают (указатель this). Статические функции-члены принадлежат классу в целом и используются для манипулирования атрибутами, общими для всех экземпляров класса. Они не нуждаются в указателе this (и не получают его). 148 ГЛАВА 6 рядном коде, откомпилированном g++, this помещается на вершину стека перед вызовом нестатической функции-члена, а вызывающая функция отвечает за удаление параметров (которых всегда не меньше одного) из стека после возврата из вызываемой. Дополнительные особенности откомпилированных программ на C++ обсуждаются в главах 8 и 20. Другие соглашения о вызове Полное описание всех соглашений о вызове заняло бы целую книгу. Они часто зависят от операционной системы, языка, компилятора и процессора, и если вы столкнетесь с кодом, сгенерированным редким компилятором, то, возможно, придется проделать небольшую исследовательскую работу. Однако есть несколько ситуаций, заслуживающих специального внимания: оптимизированный код, нестандартный код на языке ассемблера и системные вызовы. Если функции экспортируются для других программистов (например, библиотечные), то важно, чтобы они следовали хорошо известным соглашениям о вызове, иначе с ними будет трудно организовать интерфейс. С другой стороны, если функция предназначена только для внутреннего использования в программе, то соглашение о ее вызове должно быть известно лишь самой программе. В таких случаях оптимизирующие компиляторы могут выбирать альтернативные соглашения о вызове для генерирования более быстрого кода. Например, флаг /GL компилятора Microsoft C/C++ означает, что нужно произвести «оптимизацию всей программы», что может повлечь сквозную оптимизацию использования регистров, не ограниченную отдельными функциями. А ключевое слово regparm в компиляторе GNU gcc/g++ позволяет программисту указать, что до трех аргументов следует передавать в регистрах. Решая писать на языке ассемблера, программист получает полный контроль над передачей параметров своим функциям. Если только он не ставит целью сделать свои функции доступными другим программистам, то может передавать параметры, как ему заблагорассудится. Поэтому при анализе нестандартного ассемблерного кода, например подпрограмм обфускации и шелл-кода, нужно проявлять особую осторожность. ДизассемБлирОвание в Ghidra 149 Системный вызов – это специальный вид вызова функции, используемый для запроса обслуживания со стороны операционной системы. Обычно системные вызовы влекут за собой переход из режима пользователя в режим ядра, чтобы ядро операционной системы могло обслужить запрос пользователя. То, каким образом инициируется системный вызов, зависит от процессора и операционной системы. Например, в 32-разрядной ОС Linux на платформе x86 системные вызовы могут инициироваться командой INT 0x80 или sysenter, а в других операционных системах для x86 может использоваться только команда sysenter или иной номер прерывания, тогда как в 64-разрядном коде для x86 используется команда syscall. Во многих системах на платформе x86 (Linux составляет исключение) параметры системного вызова помещаются в стек, а его номер – в регистр EAX непосредственно перед инициированием системного вызова. В Linux системные вызовы принимают параметры в конкретных регистрах, а иногда в памяти, если параметров больше, чем доступных регистров.

Дополнительные сведения о кадре стека
 В любом процессоре регистры – это ограниченный ресурс, который должен совместно использоваться всеми функциями программы. Когда некоторая функция (func1) выполняется, она считает, что все регистры процессора находятся в ее распоряжении. Когда func1 вызывает другую функцию (func2), та, естественно, считает себя ничем не хуже и тоже хочет использовать все доступные регистры процессора, как ей удобно, но если func2 будет произвольно изменять регистры, то может затереть значения, от которых зависит поведение func1. Чтобы решить эту проблему, все компиляторы следуют четко определенным правилам распределения и использования регистров. Обычно эти правила называют платформенным двоичным интерфейсом прикладных программ (application binary interface – ABI). ABI разделяет регистры на две категории: сохраняемые вызывающей стороной и сохраняемые вызываемой стороной. Когда одна функция вызывает другую, вызывающая сторона обязана сохранять только регистры, принадлежащие первой категории, чтобы предотвратить потерю 150 ГЛАВА 6 их значений. Все регистры, принадлежащие второй категории, сохраняются вызываемой функцией, перед тем как она начнет использовать их для своих целей. Обычно это является частью пролога функции, причем регистры, сохраненные вызванной стороной, восстанавливаются в эпилоге функции прямо перед возвратом. Регистры, сохраняемые вызывающей стороной, называются мусорными (clobber) регистрами, потому что вызванная функция вправе модифицировать их, предварительно не сохранив. Регистры же, сохраняемые вызванной стороной, называются немусорными (no-clobber). System V ABI для 32-разрядных процессоров Intel определяет регистры EAX, ECX и EDX как сохраняемые вызывающей стороной, а регистры EBX, EDI, ESI, EBP и ESP как сохраняемые вызываемой стороной1 . Глядя на откомпилированный код, можно заметить, что компиляторы часто предпочитают использовать внутри функции регистры, сохраняемые вызывающей стороной, потому что тем самым снимают с себя обязанность сохранять и восстанавливать их содержимое при входе и выходе из функции. Размещение локальных переменных В отличие от соглашений о вызове, диктующих, как передавать функции параметры, в отношении размещения локальных переменных в памяти нет никаких соглашений. В процессе компилирования функции компилятор должен вычислить, сколько памяти нужно выделить под локальные переменные и немусорные регистры, и решить, стоит ли хранить переменные в регистрах или нужно разместить их в стеке. Как именно распределяется эта память, не важно ни для вызывающей стороны, ни для вызываемых функций, и в общем случае ничего нельзя сказать о размещении локальных переменных, глядя только на исходный код функции. Но в части кадров стека одно можно сказать точно: компилятор обязан отвести хотя бы один регистр для запоминания адреса выделенного функции кадра стека. Самый очевидный выбор – конечно, указатель стека, который, по определению, указывает на стек и, следовательно, на кадр стека текущей функции. 1 См. https://wiki.osdev.org/System_V_ABI. ДизассемБлирОвание в Ghidra 151 Примеры кадров стека Решая любую сложную задачу, например задачу обратной разработки двоичного файла, всегда следует заботиться об эффективном использовании своего времени. Если требуется разобраться в поведении дизассемблированной функции, то чем меньше времени мы потратим на изучение типичных последовательностей команд, тем больше останется на анализ трудных случаев. Прологи и эпилоги функций – отличные примеры типичных последовательностей, поэтому вы должны уметь распознавать их, понимать и быстро переходить к более интересному коду, требующему размышлений. Ghidra сводит свои знания о прологах функций к списку локальных переменных в начале листинга каждой функции, но хотя дизассемблированный код от этого становится более понятным, его объем ничуть не уменьшается. В следующих примерах мы обсудим два часто встречающихся типа кадров стека и код их создания, так чтобы, встретив такой код на практике, вы быстро проскочили мимо и перешли к сути функции. Рассмотрим следующую функцию, откомпилированную на компьютере с 32-разрядным процессором x86: void helper(int j, int k); // прототип функции void demo_stackframe(int a, int b, int c) { int x; char buffer[64]; int y; int z; // тело функции не важно, лишь бы она // вызывала другую функцию helper(z, y); } Локальные переменные в demo_stackframe занимают 76 байт (три 4-байтовых целых и 64-байтовый буфер). Какое бы соглашение о вызове – stdcall или cdecl – ни использовалось, кадр стека будет выглядеть одинаково.

###  Имена меток в Ghidra 
Запрещенные имена Существует ряд ограничений на имена переменных в функции. Приведем самые важные правила именования параметров. • Имя не должно состоять из префикса param_, за которым следует целое число, даже если оно не совпадает с именем ни одного из существующих параметров функции. • Префикс param_, за которым следуют другие символы, использовать можно. • Можно использовать префикс Param_, за которым следует целое число, поскольку имена чувствительны к регистру (хотя такая практика не рекомендуется). • Можно восстановить исходное присвоенное Ghidra имя параметра, введя param_ и затем целое число. Если использовано то же число, что было изначально, то Ghidra восстановит имя без возражений. Если же указано любое другое число, то Ghidra выведет предупреждение «Rename failed – default names may not be used» (Ошибка переименования – нельзя использовать имена по умолчанию). Нажатие в этот момент кнопки Cancel в диалоговом окне переименования параметров восстановит оригинальное имя. • Можно иметь два параметра с именами param_1 (присвоено Ghidra) и Param_1 (присвоено вами). Имена чувствительны к регистру, но такое повторное использование не рекомендуется. 180 ГЛАВА 7 Локальные переменные также чувствительны к регистру, и префикс local_ можно использовать, если суффикс содержит не только цифры. Ни для каких переменных нельзя использовать имя переменной, уже встречающееся в текущей области видимости (например, в одной функции). Ghidra откажется это делать и объяснит причину в диалоговом окне. Наконец, если вы запутались с метками, то можете просмотреть историю изменения метки переменной, нажав клавишу H или выбрав из контекстного меню команду Show All History (Показать всю историю) и введя текущее (или прошлое) имя переменной в текстовом поле. То же самое можно сделать с помощью команды SearchLabel History (ПоискИстория метки) в главном меню. Где лучше изменять имя? Имена переменных можно изменять в окнах листинга, дерева символов и декомпилятора. Результат всегда одинаков, но диалоговое окно, открывающееся при переименовании из окна листинга, содержит больше информации. Все правила именования переменных действуют при использовании любого метода. Многие примеры имен параметров, встречающиеся в этой книге, были изменены из окна листинга с помощью диалогового окна, показанного на рис. 7.5 слева. Чтобы изменить имя из окна дерева символов, щелкните правой кнопкой мыши по имени и выберите команду Rename из контекстного меню. В окне декомпилятора воспользуйтесь горячей клавишей L или командой Rename Variable в контекстном меню; соответствующее диалоговое окно показано на рис. 7.5 справа. Функционально оба окна эквивалентны, но в правом нет информации о пространстве имен и о свойствах параметра. УПравление дизассемБлирОванием 181 Рис 7.5. Переименование переменной из окна листинга или окна дерева символов (слева) и из окна декомпилятора (справа) В Ghidra пространством имен называется просто именованная область видимости. Внутри пространства имен все символы уникальны. Глобальное пространство имен содержит все символы, определенные в двоичном файле. Пространства имен функций вложены в глобальное пространство имен. В пространстве имен функции все имена переменных и метки уникальны. Функции и сами могут содержать вложенные пространства имен, например ассоциированное с предложением switch (это позволяет использовать одинаковые метки case в разных пространствах имен; например в одной функции может быть два предложения switch, в каждом из которых есть метка case 10)

### Префиксы 
О префиксах хороших и разных Когда в процессе анализа Ghidra создает метки, она использует мнемонические префиксы, за которыми следует адрес, чтобы было понятно, что предположительно находится по адресу. Ниже перечислены эти префиксы с краткими описаниями. Дополнительные сведения о семантике каждого префикса имеются в справке по Ghidra. LAB_адрес Код – автоматически сгенерированная метка (обычно адрес перехода внутри функции). DAT_адрес Данные – автоматически сгенерированное имя глобальной переменной. FUN_адрес Функция – автоматически сгенерированное имя функции. SUB_адрес Объект вызова (или эквивалента) – возможно, не функция. EXT_адрес Внешняя точка входа – вероятно, функция, написанная кем-то еще. OFF_адрес Обрезок (внутри существующих данных или кода) – вероятно, ошибка дизассемблирования. UNK_адрес Неизвестно – назначение данных не определено. Для меток функций действуют следующие специальные правила: • если удалить метку функции по умолчанию (например, FUN_08048473) в окне листинга, то префикс FUN_ будет заменен префиксом SUB_ (в данном случае получится SUB_08048473); 184 ГЛАВА 7 • добавление метки для адреса, который уже имеет метку FUN_ по умолчанию, изменяет имя функции, а не создает новую метку; • метки чувствительны к регистру, т. е. если вы хотите окончательно запутать листинг дизассемблера, то можете использовать одновременно префиксы Fun_ и fun

### Преобразование данных в Ghidra 
Форматирование операндов команд В процессе автоматического анализа Ghidra принимает много решений о форматировании операндов команд, особенно различных целочисленных констант, используемых в командах разных типов. Среди прочего эти константы могут представлять относительные смещения в командах перехода или вызова, абсолютные адреса глобальных переменных, операнды арифметических операций или постоянные, определенные программистом. Чтобы сделать листинг дизассемблера понятнее, Ghidra пытается там, где возможно, использовать символические имена вместо чисел. Иногда решения о форматировании принимаются с учетом контекста команды (например, когда это команда вызова), а иногда на основе используемых данных (например, доступ к глобальной переменной либо смещение от начала кадра стека или структуры). Зачастую точный контекст, в котором используется константа, может оказаться непонятен Ghidra. В таком случае константа обычно форматируется как шестнадцатеричное значение. Если вы не принадлежите к числу тех немногих людей, для которых работать с шестнадцатеричными числами так же естественно, как есть, спать или дышать, то пора познакомиться со средствами форматирования операндов в Ghidra. Пусть имеется следующий фрагмент в листинге дизассемблера: 08048485 MOV dword ptr [EBP + local_18],0xa 0804848c MOV byte ptr [EBP + local_58],0x41 196 ГЛАВА 7 Щелчок правой кнопкой мыши по шестнадцатеричной константе 0x41 открывает контекстное меню, показанное на рис. 7.14 (этот пример в контексте показан на рис. 6.7). Формат константы можно изменить, выбрав любое из числовых представлений в правой части рисунка или представив ее в виде символа (поскольку значение попадает в диапазон печатаемых символов ASCII). Это очень полезная возможность, потому что мы не всегда знаем, какое из многочисленных представлений окажется наиболее подходящим. Во всех случаях в меню отображается тот текст, которым будет заменен операнд при выборе данного пункта. Рис. 7.14. Варианты форматирования констант Часто программисты пользуются именованными константами в исходном коде. Такие константы могут определяться директивой #define (или ее эквивалентом) или входить в состав перечисления. К сожалению, по откомпилированному коду уже невозможно понять, что это было: символическая или литеральная числовая константа. Но зато Ghidra располагает обширным каталогом именованных констант, определенных в различных библиотеках, в т. ч. стандартной библиотеке C и в Windows API. Этот каталог доступен с помощью пункта Set Equate (Приравнять) (клавиша E) в контекстном меню для данного значения константы. Выбрав его для константы 0xa, вы увидите окно приравнивания, показанное на рис. 7.15. УПравление дизассемБлирОванием 197 Рис. 7.15. Диалоговое окно приравнивания Для заполнения этого диалогового окна используется внутренний список констант, в котором ищется константа, которую мы пытаемся отформатировать. В данном случае мы видим все известные Ghidra константы, равные 0xA. Если бы мы решили, что значение имеет отношение к созданию сетевого соединения по стандарту X.25, то могли бы выбрать символическую константу AF_CCITT, и строка в листинге дизассемблера приняла бы такой вид: 08048485 MOV dword ptr [EBP + local_18],AF_CCITT Список стандартных констант полезен, поскольку позволяет определить, можно ли связать данную константу с каким-то известным именем, и экономит много времени на поиске в документации по API. Манипулирование функциями Ghidra дает возможность манипулировать функциями в листинге дизассемблера (например, изменить решение Ghidra о принадлежности кода некоторой функции или изменить атрибуты функции). Это особенно полезно, когда вы не со198 ГЛАВА 7 гласны с результатами автоматического анализа. В некоторых случаях, например когда Ghidra не смогла найти обращение к функции, функция может оказаться неопознанной, поскольку не существует очевидного способа добраться до нее. А иногда Ghidra неправильно находит конец функции, так что листинг приходится корректировать. Проблемы с обнаружением конца функции могут возникнуть, если компилятор разнес функцию на несколько адресных диапазонов или в процессе оптимизации объединил общие завершающие последовательности двух или более функций, чтобы сэкономить память. Создание новых функций Новые функции можно создавать из существующих команд, которые еще не принадлежат никакой функции. Для создания функции щелкните правой кнопкой мыши по первой команде, которая станет ее частью, и выберите из контекстного меню пункт Create Function (Создать функцию) (или нажмите клавишу F). Если выбран диапазон адресов, то он станет телом функции. Если нет, то Ghidra проследит поток управления в попытке определить, где кончается тело. Удаление функций Чтобы удалить существующую функцию, поместите курсор внутрь ее сигнатуры и нажмите клавишу Del. Такое желание может возникнуть, если вы полагаете, что Ghidra ошиблась в автоматическом анализе, или если вы сами создали функцию по ошибке. Отметим, что хотя после удаления функция со всеми ее атрибутами перестает существовать, с самими байтами, составлявшими ее, ничего не происходит, так что при желании функцию можно будет воссоздать. Редактирование атрибутов функции Ghidra связывает с каждой функцией несколько атрибутов, которые можно просмотреть, выбрав команду WindowFunctions из меню браузера кода. (По умолчанию отображается только пять атрибутов, но щелчком по заголовку столбца можно добавить дополнительные атрибуты из имеющихся шестнадцати.) Для редактирования атрибутов откройте диалоговое окно, выУПравление дизассемБлирОванием 199 брав команду Edit Function (Редактировать функцию) из контекстного меню, которое открывается, когда курсор находится между вводным комментарием функции и последней локальной переменной перед началом дизассемблированного кода функции. Пример диалогового окна редактирования функции показан на рис. 7.16. Рис. 7.16. Диалоговое окно редактирования функции Ниже описываются атрибуты, которые можно изменить в этом диалоговом окне. Имя функции Можно изменить имя в текстовом поле в верхней части окна или в поле Function Name. Атрибуты функции Есть пять необязательных атрибутов функции. Первые четыре – Varargs (С переменным числом аргументов), In Line 200 ГЛАВА 7 (Встраиваемая), No Return (Не возвращает управление) и Use Custom Storage (Со специальной памятью) – флажки, по умолчанию сброшенные. Пятый атрибут, Call Fixup (Корректировка вызова), находится в левой нижней части окна и по умолчанию равен none, но из выпадающего списка можно выбрать другое значение. Если модифицировать любой из атрибутов функции, то Ghidra автоматически распространит новый прототип всюду, где он встречается в листинге. Флажок Varargs означает, что функция принимает переменное число аргументов (как, например, printf). Этот флажок также поднят, если вы редактируете (в текстовом поле в начале окна на рис. 7.16) список параметров, заканчивающийся многоточием (…). Флажок In Line только включает ключевое слово inline в прототип функции (имейте в виду, что если функция действительно была встроена компилятором, то вы не увидите ее как отдельный объект в листинге дизассемблера, потому что ее тело стало частью вызывающей функции). Флажок No Return используется, когда известно, что функция не возвращает управление (например, если в ней используется exit или это просто предикат для перехода к другой функции). Если для функции поднят флажок No Return, то Ghidra не будет предполагать, что байты, следующие за вызовом функции, достижимы, если только нет других свидетельств в пользу их достижимости, например команды перехода на эти байты. Флажок Use Custom Storage позволяет отменить проведенный Ghidra анализ местоположения и размера памяти, отведенной для параметров и возвращаемого значения. Соглашение о вызове Выпадающий список Calling Convention позволяет изменить соглашение о вызове, действующее для функции. Это может повлиять на результаты анализа указателя стека, поэтому важно указывать соглашение правильно. Переменные функции В области Function Variables можно редактировать переменные функции, получая помощь от Ghidra. Когда вы изменяете данные в любом из четырех столбцов, Ghidra УПравление дизассемБлирОванием 201 сообщает информацию, помогающую не наделать ошибок. Например, при попытке изменить значение в столбце Storage (Память) для param_1 будет выдано сообщение Enable 'Use Custom Storage' to allow editing of Parameter and Return Storage (Отметьте флажок 'Use Custom Storage', чтобы разрешить редактирование памяти для параметров и возвращаемого значения). Расположенные справа значки позволяют добавлять, удалять и перемещаться по списку переменных. Преобразование данных в код (и наоборот) В процессе автоматического анализа данные могут быть ошибочно сочтены кодом и представлены в виде команд. И наоборот, байты кода могут быть неправильно интерпретированы как данные и соответственно отформатированы. Это может происходить по разным причинам, например потому, что компиляторы иногда встраивают данные в кодовые секции программы, или потому, что на некоторые команды нет прямых ссылок, поэтому Ghidra решает не дизассемблировать их. В частности, обфусцированные программы сознательно стремятся затушевать различие между кодом и данными (см. главу 21). Первое, что можно предпринять для переформатирования, – отменить текущее форматирование (кода или данных). Чтобы отменить распознавание функций, кода или данных, щелкните правой кнопкой мыши по соответствующему элементу и выберите из контекстного меню команду Clear Code Bytes (Очистить байты кода) (клавиша C). В результате байты, составляющие элемент, будут представлены в виде списка неформатированных байтов. Если нужно отменить распознавание большого участка, то предварительно выделите весь список адресов, воспользовавшись буксировкой с нажатой кнопкой мыши. Например, рассмотрим листинг простой функции: 004013e0 PUSH EBP 004013e1 MOV EBP,ESP 004013e3 POP EBP 004013e4 RET 202 ГЛАВА 7 После отмены ее распознавания получится показанная ниже последовательность неклассифицированных байтов, которую можно переформатировать как угодно: 004013e0 ?? 55h U 004013e1 ?? 89h 004013e2 ?? E5h 004013e3 ?? 5Dh ] 004013e4 ?? C3h Чтобы дизассемблировать последовательность неопределенных байтов, щелкните правой кнопкой мыши по ее первому байту и выберите команду Disassemble. Ghidra применит алгоритм рекурсивного спуска, начиная с этой точки. Чтобы преобразовать в код большой участок, предварительно выделите диапазон адресов. Преобразование кода в данные чуть сложнее. Прежде всего нельзя напрямую преобразовать код в данные с помощью контекстного меню, не отменив предварительно распознавание команд, которые вы собираетесь преобразовать, и не отформатировав байты подходящим образом. Основы форматирования обсуждаются в следующем разделе. ОСНОВЫ ПРЕОБРАЗОВАНИЯ ДАННЫХ Для понимания поведения программы правильно отформатированные данные не менее важны, чем правильно отформатированный код. Ghidra получает информацию из разных источников и применяет алгоритмический подход, чтобы определить самый подходящий способ форматирования данных дизассемблером. Например: ► типы и размеры данных можно вывести из того, какие регистры используются. Если команда загружает данные из памяти в 32-разрядный регистр, значит, в памяти хранится 4-байтовый тип данных (хотя мы, возможно, и не сумеем отличить 4-байтовое целое от 4-байтового указателя); УПравление дизассемБлирОванием 203 ► для назначения типов данных параметрам функции можно использовать прототипы функций. Для этой цели в состав Ghidra входит обширная библиотека прототипов функций. Передаваемые функции параметры анализируются в попытке связать параметр с местоположением в памяти. Если такую связь удается установить, то соответствующему адресу в памяти можно сопоставить тип данных. Рассмотрим функцию, единственным параметром которой является указатель на CRITICAL_SECTION (тип данных в Windows API). Если Ghidra сумеет определить адрес, переданный при вызове этой функции, то этот адрес можно будет пометить как объект типа CRITICAL_SECTION; ► анализ последовательности байтов может дать информацию о вероятных типах данных. Именно это происходит, когда вдвоичном файле ищется строковое содержимое. Если встретилась длинная последовательность ASCII-символов, то разумно предположить, что это массив символов. В нескольких следующих разделах мы обсудим некоторые простые преобразования, применимые к данным в листинге дизассемблера. Задание типов данных Ghidra поддерживает размер данных и спецификатор типа. Наиболее употребительные спецификаторы – byte, word, dword и qword, представляющие 1-, 2-, 4- и 8-байтовые данные соответственно. Чтобы задать или изменить тип данных, щелкните правой кнопкой мыши по строке листинга, содержащей данные (т. е. не команду), и выберите тип из меню, показанного на рис. 7.17. 204 ГЛАВА 7 Рис. 7.17. Меню типов данных Этот список позволяет сразу изменить форматирование и размер выбранного элемента данных, выбрав его тип. Пункт Cycle (Перебрать) позволяет быстро перебрать группу родственных типов данных, например числовые, символьные и с плавающей точкой, как показано на рис. 7.18 (вместе с соответствующими горячими клавишами). Например, повторно нажимая F, мы будем перебирать типы float и double, потому что только они и входят в эту группу. УПравление дизассемБлирОванием 205 Рис. 7.18. Группы родственных типов По мере изменения типа размер элементов данных может уменьшаться, увеличиваться или оставаться без изменения. Если размер элемента не изменяется, то единственное видимое изменение – смена формата. Если размер элемента уменьшается, например с ddw (4 байта) до db (1 байт), то оставшиеся байты (в данном случае 3) становятся неопределенными. Если размер данных увеличивается, то Ghidra предупредит о конфликте и подскажет, как его разрешить. Пример, относящийся к размеру массива, показан на рис. 7.19. Рис. 7.19. Пример объявления массива и предупреждения (сообщение говорит, что при вводе значения, большего 200, существующие данные будут затерты) Работа со строками Команда SearchFor Strings (ПоискСтрок) открывает диалоговое окно, показанное на рис. 7.20, в котором можно задать критерий поиска строки. Большинство полей не нуждаются в объяснении, но обратим внимание на уникальную возможность Ghidra – ассоциирование модели слова с поиском. Модель слова (Word Model) позволяет определить, считается ли конкретная строка словом в данном контексте. Модели слов обсуждаются в главе 13. Результаты поиска отображаются в окне, показанном на рис. 7.21. Результаты последующих поисков будут отображаться во вкладках того же окна, а в полосе заголовка будет показана временная метка каждого поиска, чтобы в них было проще ориентироваться. 206 ГЛАВА 7 Рис. 7.20. Диалоговое окно поиска строки Рис. 7.21. Окно результатов поиска УПравление дизассемБлирОванием 207 Значки в левом столбце таблицы результатов показывают статус определения (от «не определена» до «конфликтует»). Смысл значков описан на рис. 7.22. Чтобы показать или скрыть строки из любой категории, переключите состояние соответствующего значка в полосе заголовка. Значок Определение Строка уже определена (ипотому присутствует вокне определенных строк). Такие строки обычно являются целями перекрестных ссылок Часть строки была определена. Обычно это строка, для которой ранее определенная строка является подстрокой Строка конфликтует (перекрывается) счем-то ранее определенным, например командами или данными Строка неопределена. Строка неявляется целью перекрестной ссылки, абайты обычно являются отдельными шестнадцатеричными значениями Рис. 7.22. Определения значков статуса строки Значки позволяют легко идентифицировать элементы листинга, еще не определенные как строки, и превратить их в строку или массив символов, для чего нужно их выделить и нажать кнопку Make String (Сделать строкой) или Make Char Array (Сделать массивом). Вновь определенные объекты будут отображаться в окне определенных строк, которое обсуждается в одноименном разделе главы 5. Определение массивов Один из недостатков листинга дизассемблера для кода, написанного на языке высокого уровня, – почти полное отсутствие информации о размерах массивов. Если каждый элемент массива занимает в листинге отдельную строку, то может понадобиться очень много места. В листинге ниже показана последовательность элементов в секции данных. Из того, что команды ссылаются лишь на ее первый элемент, можно сделать вывод, что это первый элемент массива. Ссылки на остальные элементы не прямые, а с применением индексной адресации относительно начала массива. 208 ГЛАВА 7 DAT_004195a4 XREF[1]: main:00411727(W) 004195a4 undefined4 ?? 004195a8 ?? ?? 004195a9 ?? ?? 004195aa ?? ?? 004195ab ?? ?? 004195ac ?? ?? 004195ad ?? ?? 004195ae ?? ?? 004195af ?? ?? 004195b0 ?? ?? 004195b1 ?? ?? 004195b2 ?? ?? 004195b3 ?? ?? 004195b4 ?? ?? 004195b5 ?? ?? 004195b6 ?? ?? Ghidra может сгруппировать соседние определения данных в одно определение массива. Чтобы создать массив, выберите первый элемент и выполните команду DataCreate Array (ДанныеСоздать массив) из контекстного меню (клавиша . Будет предложено ввести количество элементов в массиве или согласиться со значением, предложенным Ghidra по умолчанию. (Если выбран диапазон данных, а не одно значение, то Ghidra вычислит размер массива по количеству выделенных данных.) По умолчанию тип и размер элементов массива определяются на основе типа первого выделенного элемента. Массив будет представлен в сжатом формате, но его можно раскрыть, если хочется увидеть отдельные элементы. Количество элементов в одной строке задается в меню EditTool Options окна браузера кода. Более подробно массивы обсуждаются в главе 8. РЕЗЮМЕ Вместе с предыдущей эта глава охватывает большинство операций, которые чаще всего нужны пользователям Ghidra. Манипулирование листингом дизассемблера позволяет объединить ваши знания со знаниями, собранными Ghidra на УПравление дизассемБлирОванием 209 этапе анализа, и тем самым добыть ценную информацию. Как и при написании исходного кода, удачное использование имен, назначение типов данных и подробные комментарии не только помогают запомнить, что вы сделали, но и станут неоценимым подспорьем другим людям, пользующимся плодами вашего труда. В следующей главе мы перейдем к более сложным структурам данных, в частности struct в C, и поговорим о некоторых низкоуровневых деталях откомпилированного кода на C+

### Лишние перекрестные ссылки
Лишние XREF? Иногда мы замечаем в листинге аномальные, на первый взгляд, вещи. В листинге 9.2 есть две XREF типа указателя, 0040010c(*) и 004001e4(*), объяснить которые нелегко. Обе XREF, которые можно проследить до вызовов callflow в main, затруднений не вызывают. Но как быть с двумя другими? Оказывается, что это интересный артефакт данного конкретного кода. Программа была откомпилирована для Windows, в результате получился PE-файл, а эти две аномальные XREF ведут нас в заголовок PE в секции Headers листинга. Ниже показаны оба адреса, указанных в ссылках: 0040010c 00 10 00 00 ibo32 callflow BaseOfCode ... 004001e4 00 10 00 00 ibo32 callflow VirtualAddress Почему на эту функцию есть ссылка в заголовке PE? Поиск в Google поможет понять, что происходит: callflow – просто самая первая функция в текстовой секции, а два поля PE-файла косвенно ссылаются на начало текстовой секции, отсюда и неожиданные XREF, относящиеся к функции callflow

### Ghidra API

ВВЕДЕНИЕ В GHIDRA API Сейчас вы располагаете всей информацией, необходимой для написания и выполнения скриптов Ghidra. Пора воспользоваться Ghidra API, чтобы обогатить ваши умения и научиться более непосредственно взаимодействовать с объектами Ghidra. Ghidra раскрывает свой API двумя разными способами. Program API определяет многоуровневую иерархию объектов с корнем в классе Program. Этот API может изменяться при переходе от одной версии Ghidra к другой. Flat API «разравнивает» API Program, раскрывая все его уровни через один класс FlatProgramAPI. Flat API часто оказывается более удобным способом доступа ко многим конструкциям Ghidra. И к тому же он реже изменяется. Далее в этой главе мы рассмотрим наиболее полезные части Flat API. При необходимости мы будем также рассказывать о классах, входящих в Program API. Для обсуждения выбран язык Java, потому что это «родной» язык Ghidra. Ghidra API состоит из большого числа пакетов, классов и функций для интерфейса с проектами и связанными с ними файлами. Все они документированы в стиле Javadoc, и для доступа к документации достаточно нажать красный значок плюс в окне диспетчера скриптов. Эта документация в сочетании с примерами скриптов, поставляемыми вместе в Ghidra, – ваш основной источник информации об API и их использовании. Самый простой способ понять, как сделать нечто, – просмотреть имена классов Ghidra, стараясь найти нечто похожее на то, что вам нужно. По мере накопления опыта работы с Ghidra вы станете лучше ориентироваться в соглашениях об именовании и организации файлов, это поможет находить подходящие классы быстрее. Ghidra придерживается архитектуры модель–делегат, принятой в Java Swing, т. е. значения и характеристики данных хранятся в объектах модели и отображаются интерфейсными объектами-делегатами: дерево, список, таблица и т. д. Делегаты обрабатывают события, например щелчки мышью, и обновляют данные и их представления. В подавляющем большинстве случаев ваши скрипты будут иметь дело с данными, инкапсулированными в классах моделей, которые служат для 402 ГЛАВА 14 представления различных конструкций программы и обратной разработки. Далее в этом разделе мы будем рассматривать наиболее употребительные классы моделей, их связи между собой и полезные API для взаимодействия с ними. Мы не станем пытаться охватить Ghidra API целиком, так что имейте в виду, что в вашем распоряжении еще очень много функций и классов. Авторитетным источником информации по всему Ghidra API является документация в формате Javadoc, поставляемая в комплекте с Ghidra, а окончательным арбитром – исходный код Ghidra, написанный на Java. Интерфейс Address Интерфейс Address описывает модель адреса в адресном пространстве. Все адреса представлены смещениями длиной до 64 бит. Сегментированные адреса можно дополнительно квалифицировать значением сегмента. Во многих случаях смещение адреса эквивалентно виртуальному адресу в листинге программы. Метод getOffset выделяет значение смещения типа long из объекта Address. Многие функции Ghidra API требуют объектов Address в качестве аргументов или возвращают такие объекты в качестве результата. Интерфейс Symbol Интерфейс Symbol определяет общие свойства всех символов. Как минимум, символ состоит из имени и адреса. Эти атрибуты можно получить с помощью следующих методов: Address getAddress() Возвращает адрес символа. String getName() Возвращает имя символа. Интерфейс Reference Интерфейс Reference моделирует перекрестную ссылку (см. главу 9) между исходным и конечным адресами. Ссылка характеризуется своим типом. Из полезных методов Reference отметим следующие: ОснОвы наПисания скриПтОв для Ghidra 403 public Address getFromAddress() Возвращает исходный адрес ссылки. public Address getToAddress() Возвращает конечный адрес ссылки. public RefType getReferenceType() Возвращает объект RefType, описывающий природу связи между исходным и конечным адресами. Класс GhidraScript Этот класс не моделирует какой-то конкретный атрибут двоичного файла, но каждый скрипт должен быть подклассом GhidraScript, который, в свою очередь, является подклассом FlatProgramAPI. Благодаря этому скрипты могут мгновенно обращаться ко всему Flat API, а вам нужно только предоставить реализацию метода protected abstract void run() throws Exception; который, надо полагать, заставляет ваш скрипт делать чтото интересное. Остальные части класса GhidraScript дают доступ к различным общим ресурсам для взаимодействия с пользователем Ghidra и анализируемой программой. В следующих разделах перечислены некоторые полезные функции и данные-члены этого класса (включая унаследованные от FlatProgramAPI). Полезные данные-члены Класс GhidraScript предоставляет удобный доступ к ряду объектов, к которым часто обращаются скрипты. protected Program currentProgram; Текущая открытая программа. Класс Program обсуждается ниже. Это поле открывает доступ к более интересной информации, например спискам команд и символов. protected Address currentAddress; Адрес, ассоциированный с текущим положением курсора. Класс Address обсуждается ниже. 404 ГЛАВА 14 protected ProgramLocation currentLocation; Объект ProgramLocation представляет текущее положение курсора, включая его адрес, строку, столбец и другую информацию. protected ProgramSelection currentSelection; Объект ProgramSelection представляет диапазон адресов, выбранных в пользовательском интерфейсе Ghidra. protected TaskMonitor monitor; Класс TaskMonitor обновляет состояние долго работающих задач и проверяет, не была ли задача отменена пользователем (monitor.isCancelled()). Любой написанный вами долго работающий цикл должен включать обращения к функции monitor.isCancelled в качестве дополнительного условия завершения – только так можно распознать, что пользователь пытался снять скрипт. Функции пользовательского интерфейса Класс GhidraScript содержит вспомогательные функции для простых операций пользовательского интерфейса, от простого вывода сообщений до интерактивных элементов. Ниже описаны некоторые общеупотребительные функции. public void println(String message) Печатает сообщение message, сопровождаемое переводом строки, в окне консоли Ghidra. Полезна для ненавязчивой печати сообщений о состоянии или результатов скрипта. public void printf(String message, Object... args) Сообщение message выступает в роли форматной строки Java, в которую подставляются аргументы args, и результат выводится в окно консоли Ghidra. public void popup(final String message) Отображает сообщение message в диалоговом окне. Для продолжения работы скрипта пользователь должен нажать кнопку OK. Это более навязчивый способ показать пользователю сообщение о состоянии. ОснОвы наПисания скриПтОв для Ghidra 405 public String askString(String title, String message) Одна из многих имеющихся функций семейства ask. Функция askString открывает диалоговое окно, в котором message выступает в роли приглашения, и возвращает текст, введенный пользователем. public boolean askYesNo(String title, String question) Задает в диалоговом окне вопрос, требующий ответа «да» или «нет». Возвращает true в случае «да» и false в случае «нет». public Address askAddress(String title, String message) Открывает диалоговое окно, в котором message выступает в роли приглашения, и преобразует данные, введенные пользователем, в объект Address. public int askInt(String title, String message) Открывает диалоговое окно, в котором message выступает в роли приглашения, и преобразует данные, введенные пользователем, в число типа int. public File askFile(final String title, final String approveButtonText) Отображает диалоговое окно выбора файла и возвращает объект File, представляющий файл, выбранный пользователем. public File askDirectory(final String title, final String approveButtonText) Отображает диалоговое окно выбора файла и возвращает объект File, представляющий каталог, выбранный пользователем. public boolean goTo(Address address) Позиционирует все связанные окна дизассемблера, так чтобы был виден адрес address. Перегруженные варианты этой функции принимают в качестве аргумента объект типа Symbol или Function и позиционируют окна на нем. Функции для работы с адресами Для процессора адрес – обычно просто число, указывающее адрес в памяти. Ghidra моделирует адреса с помощью класса Address. Класс GhidraScript предоставляет функцию-обертку для преобразования числа в объект Address: 406 ГЛАВА 14 public Address toAddr(long offset) Вспомогательная функция, создающая объект Addressв адресном пространстве по умолчанию. Чтение памяти программы Класс Memory представляет непрерывный диапазон байтов, например содержимое исполняемого файла, загруженного в Ghidra. Внутри объекта Memory с каждым значением байта ассоциирован адрес, хотя адреса могут быть помечены как неинициализированные, т. е. из них нельзя извлечь никакого значения. Ghidra возбуждает исключение MemoryAccessException при попытке обратиться к элементу внутри объекта Memory с недействительным адресом. Полное описание всех функций API см. в документации по классу Memory. Ниже перечислены функции, раскрывающие часть функциональности класса Memory с помощью Flat API: public byte getByte(Address addr) Возвращает значение одного байта по адресу addr. Тип данных byte в Java соответствует байту со знаком, т. е. изменяется в диапазоне –128..127. public byte[] getBytes(Address addr, int length) Возвращает length байт из памяти, начиная с addr. public int getInt(Address addr) Возвращает 4-байтовое значение, начинающееся с addr, в виде типа Java int. При сборке целого числа из байтов учитывается порядок байтов и архитектура, для которой собран двоичный файл. public long getLong(Address addr) Возвращает 8-байтовое значение, начинающееся с addr, в виде типа Java long. При сборке длинного целого числа из байтов учитывается порядок байтов и архитектура, для которой собран двоичный файл. Функции поиска в программе Средства поиска Ghidra разбросаны по разным классам Program API в зависимости от типа искомого элемента. В классе Memory находится функциональность поиска неформатированных байОснОвы наПисания скриПтОв для Ghidra 407 тов. Поиск по элементам кода (например, Data и Instruction) и тексту комментариев реализован в классе Listing, там же находятся соответствующие итераторы. Поиск по символам и меткам и ассоциированные итераторы включены в класс SymbolTable. Ниже перечислены функции, раскрывающие часть функциональности поиска с помощью Flat API: public Data getFirstData() Возвращает первый элемент данных в программе. public Data getDataAfter(Data data) Возвращает следующий после data элемент данных или null, если такового не существует. public Data getDataAt(Address address) Возвращает элемент данных по адресу address или null, если такового не существует. public Instruction getFirstInstruction() Возвращает первую команду в программе. public Instruction getInstructionAfter(Instruction instruction) Возвращает следующую после instruction команду или null, если таковой не существует. public Instruction getInstructionAt(Address address) Возвращает команду по адресу address или null, если таковой не существует. public Address find(String text) Ищет строку text в окне листинга. Компоненты листинга просматриваются в следующем порядке: 1) вводные комментарии; 2) предварительные комментарии; 3) метки; 4) мнемонические команды и операнды; 5) концевые комментарии; 6) повторяющиеся комментарии; 7) заключительные комментарии. В случае успешного поиска возвращается совпавший адрес. Заметим, что поскольку поиск производится в определенном порядке, может быть возвращено не первое вхождение текста в листинг дизассемблера в смысле строгого возрастания адресов. 408 ГЛАВА 14 public Address find(Address start, byte[] values); Ищет в памяти, начиная с адреса addr, заданную последовательность байтов values. Если addr равен null, то поиск начинается с наименьшего действительного адреса в двоичном файле. В случае успешного поиска возвращается адрес первого байта найденной последовательности. public Address findBytes(Address start, String byteString) Ищет в памяти, начиная с адреса addr, заданную строку байтов byteString, которая может содержать регулярные выражения. Если addr равен null, то поиск начинается с наименьшего действительного адреса в двоичном файле. В случае успешного поиска возвращается адрес первого байта найденной последовательности. Манипулирование метками и символами Необходимость манипулировать именованными адресами в базе данных Ghidra возникает в скриптах довольно часто. Для этого предоставляются следующие функции. public Symbol getSymbolAt(Address address) Возвращает символ Symbol, ассоциированный с данным адресом, или null, если с адресом не связан никакой символ. public Symbol createLabel(Address address, String name, boolean makePrimary) Сопоставляет имя name адресу address. Ghidra допускает сопоставление нескольких имен одному адресу. Если makePrimary равно true, то новое имя становится основным именем, связанным с данным адресом. public List


### Ghidra CLI 
НЕОБСЛУЖИВАЕМЫЙ РЕЖИМ GHIDRA В предыдущих главах нас интересовало исследование одного файла в рамках одного проекта, чему способствовал графический пользовательский интерфейс (GUI) Ghidra. Но помимо GUI, Ghidra располагает интерфейсом командной строки, который называется необслуживаемым (headless) анализатором Ghidra. Необслуживаемый анализатор предоставляет часть возможностей Ghidra GUI, в т. ч. возможность работать с проектами и файлами, но лучше приспособлен для пакетной обработки и управления Ghidra с помощью скриптов. В этой главе мы обсудим, как необслуживаемый режим Ghidra может помочь при выполнении повторяющихся задач для большого числа файлов. Начнем со знакомого примера, а затем перейдем к более сложным случаям. ПРИСТУПАЯ К РАБОТЕ Вспомним, как мы впервые подступились к Ghidra в главе 4. Мы успешно выполнили следующие шаги: 1) запустить Ghidra; 2) создать новый проект; 3) выбрать место для проекта; 4) импортировать файл в проект; 5) автоматически проанализировать файл; 6) сохраниться и выйти. Повторим эти шаги, воспользовавшись командным режимом необслуживаемого анализатора. Сам необслуживаемый анализатор (analyzeHeadless или analyzeHeadless.bat), а также полезный файл analyzeHeadlessREADME.html можно найти в подкаталоге support установочного каталога Ghidra. Чтобы упростить пути к файлам, мы временно поместили файл global_array_demo_x64 в тот же каталог. Сначала опишем команды и параметры, необходимые для выполнения отдельных задач, а затем соберем все вместе и достигнем поставленной цели. Хотя существенных отличий от предыдущих глав и нет, при работе из командной строки между тремя платформами, поддерживаемыми Ghidra, различий больше. В примерах ниже мы будем работать с Windows, но отмечать важные отличия на других платформах. Прямая или обратная косая черта? Важное различие между операционными системами, поддерживаемыми Ghidra, – способ записи путей в файловой системе. В целом синтаксис похож, но символы-разделители компонентов пути разные. В Windows используется обратная косая черта, а в Linux и macOS – прямая. Путь в Windows выглядит так: D:\GhidraProjects\ch16\demo_stackframe_32 А такой же путь в Linux и macOS – так: /GhidraProjects/ch16/demo_stackframe_32 458 ГЛАВА 16 Путаница осложняется еще и тем, что в Windows для разделения компонентов URL-адреса и для обозначения флагов в командной строке (в т. ч. в документации Ghidra) используется прямая косая черта. Операционные системы знают об этой проблеме и стараются принимать оба символа, но не всегда предсказуемым образом. В примерах из этой главы мы будем использовать соглашения Windows, так что читатели могут радоваться обратной совместимости с DOS. Шаг 1: запуск Ghidra Этот шаг выполняется командой analyzeHeadless. Все дополнительные шаги определяются параметрами данной команды. Если запустить analyzeHeadless без параметров, то будет выведено сообщение о порядке использования, в котором перечислены все параметры (рис. 16.1). Для запуска Ghidra необходимо указать некоторые из них. Рис. 16.1. Порядок запуска необслуживаемого анализатора Шаги 2 и 3: создать новый проект Ghidra в указанном месте В необслуживаемом режиме Ghidra создает проект, если он еще не существует. Если в указанном месте уже есть проект, то Ghidra открывает его. Поэтому необходимы два параметра: НеОБслУживаемый режим Ghidra 459 местоположение и имя проекта. Следующая команда создает проект CH16 в каталоге D:\GhidraProjects: analyzeHeadless D:\GhidraProjects CH16 Это необходимый минимум – при таких параметрах Ghidra откроет проект и больше ничего не сделает. На самом деле Ghidra прямо так и скажет: Nothing to do...must specify -import, -process, or prescript and/or postscript. (Нечего делать... необходимо задать флаг -import, -process или prescript и (или) postscript.) Шаг 4: импортировать файл в проект Для импорта файла необходимо задать флаг -import и имя файла. Мы импортируем файл global_array_demo_x64, который уже использовали ранее. Как было отмечено выше, для простоты мы поместили файл в каталог support. Но можно было бы задать в командной строке полный путь к файлу. analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 Шаги 5 и 6: автоматический анализ файла, сохранение и выход В необслуживаемом режиме автоматический анализ и сохранение производятся по умолчанию, поэтому команда на шаге 4 делает все, что нам нужно. Параметр нужен, чтобы отменить анализ файла (-noanalysis), существуют также параметры, управляющие порядком сохранения проекта и связанных с ним файлов. Вот как выглядит полная команда для достижения всех шести заявленных целей: analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 460 ГЛАВА 16 Как часто бывает с консольными командами, возникает вопрос: «Откуда мне знать, происходит ли что-нибудь?» Первый признак успеха (или неудачи) – сообщения, отображаемые на консоли. Информационные сообщения, начинающиеся словом INFO, сообщают о ходе работы. Сообщения об ошибках начинаются словом ERROR. В листинге 16.1 показано подмножество сообщений, в т. ч. сообщение об ошибке:  INFO HEADLESS Script Paths: C:\Users\Ghidrabook\ghidra_scripts  D:\ghidra_PUBLIC\Ghidra\Extensions\SimpleROP\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\Base\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\BytePatterns\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\Decompiler\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\FileFormats\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\FunctionID\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\GnuDemangler\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\Python\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\VersionTracking\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Processors\8051\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Processors\DATA\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Processors\PIC\ghidra_scripts(HeadlessAnalyzer) INFO HEADLESS: execution starts (HeadlessAnalyzer) INFO Opening existing project: D:\GhidraProjects\CH16 (HeadlessAnalyzer)  ERROR Abort due to Headless analyzer error: ghidra.framework.store.LockException: Unable to lock project! D:\GhidraProjects\CH16 (HeadlessAnalyzer) java.io.IOException: ghidra.framework.store.LockException: Unable to lock project! D:\GhidraProjects\CH16 ... Рис. 16.1. Ошибка в работе необслуживаемого анализатора Перечислены пути к скриптам, используемые в необслуживаемом режиме . Ниже в этой главе мы покажем, как применить дополнительные скрипты в необслуживаемых командах. Созданное в предыдущей главе расширение SimpleROP включено в пути к скриптам , потому что любое расширение добавляет новый путь. Исключение LockException  – пожалуй, самая частая ошибка при работе с необслуживаемым анализатором. Ошибка имеет место, когда мы пытаемся применить НеОБслУживаемый режим Ghidra 461 анализатор к проекту, который уже открыт в другом экземпляре Ghidra. В таком случае необслуживаемый анализатор не может захватить блокировку на проект, поэтому команда завершается ошибкой. Чтобы исправить ошибку, закройте экземпляр Ghidra, в котором открыт проект CH16, и снова запустите команду. На рис. 16.2 показано, чем заканчивается вывод при успешном выполнении команды. Информация примерно такая же, как во всплывающем окне, которое мы видели при анализе файлов в графическом интерфейсе Ghidra. Рис. 16.2. Вывод результатов необслуживаемого анализатора на консоль Чтобы проверить результаты в Ghidra GUI, откройте проект и убедитесь, что файл был загружен, как показано на рис. 16.3, а затем откройте файл в браузере кода и проверьте, что анализ был выполнен. 462 ГЛАВА 16 Рис. 16.3. Подтверждение создания проекта и загрузки файла в графическом интерфейсе Ghidra Повторив сделанное ранее в необслуживаемом режиме Ghidra, рассмотрим ситуации, когда необслуживаемый режим оказывается лучше GUI. Чтобы создать проект, загрузить и проанализировать все файлы, показанные на рис. 16.4, с помощью Ghidra GUI, нам пришлось загружать файлы по одному или выбрать их перед выполнением операции пакетного импорта, как было описано в разделе «Пакетный импорт» главы 11. В необслуживаемом режиме мы можем просто указать каталог и проанализировать все находящиеся в нем файлы. НеОБслУживаемый режим Ghidra 463 Рис. 16.4. Входной каталог с примерами для необслуживаемого режима Ghidra Следующая команда просит необслуживаемый анализатор открыть или создать проект с именем CH16 в каталоге D:\GhidraProjects, а затем импортировать и проанализировать все файлы в каталоге D:\ch16: analyzeHeadless D:\GhidraProjects CH16 -import D:\ch16 После того как команда завершится, мы можем открыть новый проект в Ghidra GUI и увидим там все проанализированные файлы, как показано на рис. 16.5. Ни подкаталог D:\ch16\ CH16_subdirectory, ни находящиеся в нем файлы в проекте не показываются. Мы вернемся к этому вопросу, когда будем обсуждать дополнительные флаги и параметры необслуживаемого анализатора в следующем разделе. 464 ГЛАВА 16 Рис. 16.5. Проект, получившийся после задания каталога в необслуживаемом режиме Флаги и параметры Простые примеры использования необслуживаемого режима Ghidra для создания проекта, загрузки и анализа одного файла и пакетного импорта целого каталога – лишь начало. Мы, правда, не сможем обсудить все возможности необслуживаемого режима, но дадим краткий обзор всех имеющихся на данный момент флагов. Флаги общего назначения Ниже приведены и проиллюстрированы на простых примерах краткие описания дополнительных флагов, которые позволяют управлять происходящим (перенесенные строки напечатаны с отступом). Когда уместно, обсуждаются типичные ошибки. Редкие ошибки оставляем читателю в качестве упражнения на освоение справки по Ghidra. -log logfilepath При выполнении команды многое может пойти не так (или так). По счастью, плагины Ghidra непрерывно сообщают о том, что происходит во время работы. В Ghidra GUI эта обратная НеОБслУживаемый режим Ghidra 465 связь не так существенна (поскольку на экране мы и так видим, что творится), но в необслуживаемом режиме важна. По умолчанию журнал записывается в файл .ghidra/. ghidra__PUBLIC/application.log в домашнем каталоге пользователя. Можно указать другое место, задав флаг -log в командной строке. Чтобы создать каталог CH16-logs и записать журнал в файл CH16-logfile, введите такую команду: analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -log D:\GhidraProjects\CH16-logs\CH16-Logfile -noanalysis Этот флаг говорит Ghidra, что не нужно анализировать файлы, импортированные в командной строке. Если выполнить показанную ниже команду и открыть файл global_ array_demo_x64 в Ghidra GUI, то мы увидим загруженный, но не проанализированный файл в проекте CH16: analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -noanalysis -overwrite В листинге 16.1 мы видели ошибку, случившуюся, когда Ghidra попыталась открыть уже открытый проект. Другая типичная ошибка возникает, когда Ghidra пытается импортировать файл в проект, а файл уже был импортирован. Чтобы импортировать новую версию файла или перезаписать существующий файл, несмотря ни на что, задайте флаг -overwrite. Если этот флаг не задан, то выполнение следующей команды два раза подряд приведет к ошибке при втором запуске. А с флагом -overwrite мы можем запускать ее сколько угодно раз. analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -overwrite 466 ГЛАВА 16 -readOnly Чтобы импортировать файл, но не сохранять его в проекте, задайте флаг -readOnly. В таком случае флаг -overwrite игнорируется (если он задан). Этот флаг имеет смысл также при задании вместе с флагом -process, а не -import . Флаг -process будет рассмотрен ниже в этой главе. analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -readOnly -deleteProject Этот флаг означает, что Ghidra не должна сохранять проект, созданный благодаря флагу –import. Его можно использовать вместе с любыми флагами, но предполагается, что задан флаг -readOnly (даже если он опущен). Вновь созданный проект удаляется после завершения анализа. Существующий проект с помощью этого флага не удаляется. analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -deleteProject -recursive По умолчанию Ghidra не заглядывает в подкаталоги, когда ее просят обработать целый каталог. Этот флаг означает, что Ghidra должна рекурсивно обрабатывать каталог, т. е. заходить во все встретившиеся по пути подкаталоги. Например, следующая команда требует обработать тот же каталог ch16, что и раньше, но теперь рекурсивно: analyzeHeadless D:\GhidraProjects CH16 -import D:\ch16 -recursive Открыв проект CH16 после завершения этой команды, мы увидим структуру, показанную на рис. 16.6. В отличие от рис. 16.5, подкаталог CH16_subdirectory теперь включен в проект вместе с находящимся в нем файлом. НеОБслУживаемый режим Ghidra 467 Рис. 16.6. Результат обработки проекта необслуживаемым анализатором с флагом -recursive Метасимволы! Метасимволы – простой способ выбрать несколько файлов в необслуживаемом режиме, не перечисляя их по отдельности. Звездочка (*) сопоставляется с любой последовательностью символов, а вопросительный знак (?) с одним любым символом. Чтобы загрузить и проанализировать только 32-разрядные двоичные файлы, нужно воспользоваться метасимволами следующим образом: analyzeHeadless D:\GhidraProjects CH16 -import D:\ch16\demo_ stackframe_32* Эта команда создаст проект CH16, а затем загрузит в него и проанализирует все 32-разрядные файлы в каталоге ch16. Результат показан на рис. 16.7. Подробнее об использовании метасимволов для задания файлов, подлежащих импорту и обработке, см. файл analyzeHeadlessREADME.html. Далее мы еще столкнемся с метасимволами в примерах необслуживаемых скриптов Ghidra. 468 ГЛАВА 16 Рис. 16.7. Файлы проекта, загруженные при задании demo_ stackframe_32* с метасимволами -analysisTimeoutPerFile seconds Когда вы анализировали файлы (или сидели и наблюдали за тем, как это делает Ghidra), вы, возможно, обратили внимание на несколько факторов, влияющих на время анализа, как то: размер файла, скомпонован он статически или динамически, параметры декомпилятора. Но каким бы ни было содержимое файла и параметры, заранее невозможно сказать, сколько времени займет анализ. В необслуживаемом режиме Ghidra, особенно если вы обрабатываете сразу много файлов, можно задать флаг analysisTimeoutPerFile, гарантирующий, что задача закончится за разумное время. Тайм-аут задается в секундах, и по его истечении анализ прерывается. Например, команда Ghidra, которую мы все время приводим в пример, в нашей системе работает чуть дольше одной секунды (см. рис. 16.2). Если бы мы действительно захотели ограничить время работы этого скрипта, то могли бы задать следующую команду, которая прекратила бы анализ через одну секунду: analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -analysisTimeoutPerFile 1 НеОБслУживаемый режим Ghidra 469 Тогда мы увидели бы на консоли картину, показанную на рис. 16.8. Рис. 16.8. Предупреждение на консоли о прерывании анализа по тайм-ауту -processor languageID и-cspec compilerSpecID Как показано в предыдущих примерах, обычно Ghidra отлично справляется с определением информации о файле и дает правильные рекомендации по импорту. Пример окна с рекомендациями для конкретного файла показан на рис. 16.9. Это окно отображается всегда при использовании GUI для импорта файла в проект. Рис. 16.9. Диалоговое окно подтверждения импорта в Ghidra GUI Если вы полагаете, что обладаете дополнительной информацией о языке или компиляторе, то можете нажать кнопку с многоточием справа от спецификации языка. Тогда откроется окно, показанное на рис. 16.10, где вы сможете выбрать язык и спецификацию компилятора. 470 ГЛАВА 16 Рис. 16.10. Окно выбора языка и спецификации компилятора Чтобы сделать то же самое внеобслуживаемом режиме Ghidra, воспользуйтесь флагом -cspec и (или) -processor, как показано ниже. Задавать -cspec можно только вместе с -processor, но -processor можно задавать и без -cspec – в таком случае Ghidra выбирает компилятор, ассоциированный с данным процессором по умолчанию. analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -processor "x86:LE:64:default" -cspec "gcc" -loader loadername Флаг -loader самый сложный из всех параметров необслуживаемого анализатора. Аргумент loadername задает имя модуля загрузчика Ghidra (обсуждается в главе 17), который будет использоваться для импорта файла в поименованный проект. Вот несколько примеров имен загрузчиков: PeLoader, ElfLoader, MachoLoader. Каждый модуль загрузчика понимает еще и свои собственные аргументы в командной строке. Эти дополнительные аргументы описаны в файле support/analyzeHeadlessREADME.html. -max-cpu number Этот флаг позволяет ограничить сверху количество процессорных ядер, задействованных для обработки необслуживаемой команды Ghidra. Флаг требует задания целого числа в качестве аргумента. Если его значение меньше 1, то максимальное число ядер будет равно 1. НеОБслУживаемый режим Ghidra 471 analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -max-cpu 5 Флаги при работе с сервером Некоторые команды используются только при взаимодействии с сервером Ghidra. Поскольку эта тема не является для нас основной, мы лишь кратко упомянем эти команды. Дополнительные сведения можно найти в файле analyzeheadlessREADME.html. ghidra://server[:port]/repository_name[/folder_path] Во всех предыдущих примерах мы задавали местоположение или имя проекта. Этот параметр позволяет задать репозиторий на сервере Ghidra и необязательный путь к папке. -p При работе с сервером Ghidra этот флаг выводит на консоль приглашение для ввода пароля. -connect [userID] Этот флаг позволяет задать идентификатор пользователя userID для подключения к серверу Ghidra Server вместо подразумеваемого по умолчанию. -keystore path Этот флаг позволяет задать файл с закрытым ключом при аутентификации по протоколу PKI или SSH. -commit ["comment"] Если включен режим фиксации по умолчанию, то этот флаг позволяет задать комментарий, связанный с данной фиксацией. Флаги скриптов Пожалуй, самые важные приложения необслуживаемого режима Ghidra связаны со скриптами. В главах 14 и 15 было показано, как создаются и используются скрипты в графическом интерфейсе. Представив флаги скриптов, мы затем продемонстрируем, каким мощным инструментом может быть необслуживаемый режим Ghidra в скриптовом контексте. 472 ГЛАВА 16 -process [project_file] Этот флаг означает, что выбранные файлы нужно обработать, а не импортировать. Если файл не указан, то обрабатываются все файлы в папке проекта. Все указанные файлы будут также проанализированы, если только не задан флаг -noanalysis. Ghidra понимает два метасимвола (* и ?) в аргументе флага -process, чтобы упростить задание нескольких файлов. В отличие от флага ‑import, в данном случае задаются имена импортированных в проект файлов, а не файлов в локальной файловой системе, поэтому имена, содержащие эти метасимволы, нужно заключать в кавычки, чтобы оболочка не расширила их раньше времени. -scriptPath "path1[;path2...]" По умолчанию в необслуживаемом режиме рассматривается много путей к скриптам по умолчанию, а также к скриптам импортированных расширений, как показано на рис. 16.1. Чтобы еще расширить список путей, по которым Ghidra ищет скрипты, воспользуйтесь флагом –scriptPath, задав в качестве аргумента заключенный в кавычки список путей. В путях распознаются две специальные переменные: $GHIDRA_HOME и $USER_HOME. Первая ссылается на установочный каталог Ghidra, вторая – на домашний каталог пользователя. Отметим, что это не переменные окружения, и, значит, ваша оболочка может потребовать, чтобы начальный знак $ экранировался, иначе он не будет передан Ghidra. В команде ниже в состав путей к скриптам добавляется каталог D:\GhidraScripts: analyzeHeadless D:\GhidraProjects CH16 -import global_array_demo_x64 -scriptPath "D:\GhidraScripts" После выполнения этой команды каталог D:\GhidraScripts будет включен в состав путей к скриптам: INFO HEADLESS Script Paths: D:\GhidraScripts C:\Users\Ghidrabook\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Extensions\SimpleROP\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\Base\ghidra_scripts НеОБслУживаемый режим Ghidra 473 D:\ghidra_PUBLIC\Ghidra\Features\BytePatterns\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\Decompiler\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\FileFormats\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\FunctionID\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\GnuDemangler\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\Python\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Features\VersionTracking\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Processors\8051\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Processors\DATA\ghidra_scripts D:\ghidra_PUBLIC\Ghidra\Processors\PIC\ghidra_scripts (HeadlessAnalyzer) INFO HEADLESS: execution starts (HeadlessAnalyzer) -preScript Этот флаг задает имя скрипта, который нужно выполнить перед анализом. Скрипт может содержать необязательный список аргументов. -postScript Этот флаг задает имя скрипта, который нужно выполнить после анализа. Скрипт может содержать необязательный список аргументов. -propertiesPath Этот флаг задает путь к файлам свойств, ассоциированным со скриптом. Файлы свойств передают входные данные скриптам, работающим в необслуживаемом режиме. Примеры скритов и их файлов свойств имеются в документации по необслуживаемому анализатору. -okToDelete Поскольку скрипт может делать все, что задумал его автор, он, в частности, может и удалять (или попробовать удалить) файлы, являющиеся частью проекта Ghidra. Чтобы предотвратить этот нежелательный побочный эффект, Ghidra при работе в необслуживаемом режиме не позволяет удалять файлы из скрипта, если только не был задан флаг -okToDelete. Примечание: этот флаг необязателен, если задан флаг -import.

### ЗАВИСИМОСТЬ ОТ КОМПИЛЯТОРА
Если до сих пор вы честно работали, то теперь обладаете необходимыми для эффективного использования Ghidra навыками и, что еще важнее, можете заставить ее покориться вашей воле. Следующий шаг – научиться справляться с теми проблемами, которые подкидывают вам двоичные файлы (а вовсе не Ghidra). В зависимости от мотивов, заставивших вас пялиться на ассемблерный код, вы либо хорошо знакомы с тем, на что смотрите, либо понятия не имеете, с чем можете столкнуться. Если вы денно и нощно изучаете код, скомпилированный gcc на платформе Linux, то, наверное, привыкли к его стилю, но можете быть ошарашены, впервые увидев отладочную версию программы, сгенерированную компилятором Microsoft C/C++. Если ваша профессия – анализ вредоносного ПО, то не удивимся, если каждый день еще до обеда вы любуетесь на код, созданный компиляторами gcc, clang, Microsoft C++, Delphi и др. Как и вы, Ghidra больше знакома с одними компиляторами и меньше с другими, а знакомство с кодом, сгенерированным каким-то определенным компилятором, вовсе не гарантирует, что удастся распознать высокоуровневые конструкции в коде, созданном совершенно другим компилятором (или даже другой версией компилятора из того же семейства). Чем всецело полагаться на аналитические способности Ghidra в распознавании типичных программных конструкций и структур данных, следует всегда быть готовым применить собственные навыки: свое знакомство с данным языком ассемблера, знание компиляторов и умение правильно интерпретировать результаты дизассемблирования. В этой главе мы рассмотрим, как различия между компиляторами проявляются в листингах дизассемблера. Мы будем работать с откомпилированным кодом на C, потому что разнообразие компиляторов C и целевых платформ позволит получить фундаментальные знания, которые можно распространить и на другие компилируемые языки. ВЫСОКОУРОВНЕВЫЕ КОНСТРУКЦИИ Иногда различия между компиляторами чисто косметические, но бывает и так, что они весьма значительны. В этом разделе мы рассмотрим высокоуровневые конструкции языка и покажем, как сильно выбор компилятора и его параметров может влиять на результат. Начнем с предложений switch и двух механизмов, чаще всего используемых для выбора ветви case. Затем посмотрим, как параметры компилятора влияют на генерацию кода типичных выражений, после чего перейдем к тому, как разные компиляторы реализуют конструкции C++ и инициализируют программу. Предложения switch Предложение switch языка C часто является предметом оптимизации компилятором. Цель таких оптимизаций – максимально эффективно найти ветвь case, соответствующую переменной switch, но применимый тип поиска диктуется распределением значений переменной switch. Поскольку эффективность поиска измеряется количеством сравнений, необходимых для нахождения правильной ветви case, мы можем проследить логику, используемую компи592 ГЛАВА 20 лятором для отыскания наилучшего представления таблицы switch. Эффективнее всего алгоритмы с постоянным временем работы, например табличный поиск1 . На другом конце спектра находится линейный поиск, когда в худшем случае требуется сравнить переменную switch с каждой меткой case, чтобы найти совпадение или выбрать ветвь по умолчанию. Такой алгоритм наименее эффективен2 . Двоичный поиск в среднем гораздо эффективнее линейного, но у него есть свои ограничения – список должен быть отсортирован3 . Чтобы выбрать самую эффективную реализацию конкретного предложения switch, нужно понимать, как распределение меток влияет на решение компилятора. Если метки идут подряд или близко к тому, как в исходном коде в листинге 20.1, то компилятор обычно прибегает к табличному поиску, чтобы сопоставить переменной switch адрес соответствующей ветви case, – точнее, он использует таблицу переходов. switch (a) { /** ПРИМЕЧАНИЕ: тела ветвей case для краткости опущены **/ case 1: /*...*/ break; case 2: /*...*/ break; case 3: /*...*/ break; case 4: /*...*/ break; case 5: /*...*/ break; case 6: /*...*/ break; case 7: /*...*/ break; case 8: /*...*/ break; case 9: /*...*/ break; case 10: /*...*/ break; case 11: /*...*/ break; case 12: /*...*/ break; } Листинг 20.1. Предложение switch с последовательными метками 1 Для любителей анализа алгоритмов скажем, что табличный поиск позволяет найти нужную ветвь за постоянное число операций, не зависящее от размера пространства поиска. Как вы, наверное, помните, про такие алгоритмы говорят, что они имеют сложность O(1). 2 Линейные алгоритмы имеют сложность O(n) и, к счастью, не используются в предложениях switch. 3 Двоичный поиск имеет сложность O(log n). ЗависимОсть от кОмПилятОра 593 Таблица переходов – это массив указателей, каждый элемент которой содержит адрес перехода. Во время выполнения нужный переход выбирается из таблицы по индексу. Таблицы переходов хорошо работают, когда метки расположены плотно, т. е. в основном являются соседними целыми числами. Компиляторы учитывают это, решая, стоит ли использовать таблицу переходов. Для любого предложения switch мы можем вычислить минимальное количество элементов в соответствующей ему таблице переходов по формуле: num_entries = max_case_value – min_case_value + 1 Тогда плотность, или коэффициент заполнения таблицы переходов, вычисляется следующим образом: density = num_cases / num_entries Если все элементы списка – последовательные целые числа, то плотность равна 100 процентов (1.0). Наконец, для хранения таблицы переходов требуется память объемом table_size = num_entries * sizeof(void*) Предложение switch со стопроцентной плотностью будет реализовано с помощью таблицы переходов. Если же плотность равна, скажем, 30 процентам, то компилятор вряд ли применит таблицу переходов, потому что в ней придется заводить записи в том числе для отсутствующих меток, и на них придется 70 процентов всей таблицы. Если num_entries равно 30, то таблица переходов будет содержать 21 запись для меток, на которые нет ссылок. В 64-разрядной системе это 168 из 240 байт, выделенных под таблицу; накладные расходы вроде бы не слишком велики, но если num_entries равно 300, то они составляют уже 1680 байт, а это слишком много для 90 реально существующих ветвей case. Компилятор, оптимизирующий быстродействие, может предпочесть таблицу переходов, тогда как компилятор, оптимизирующий память, скорее, выберет альтернативную реализацию с меньшими затратами по памяти – двоичный поиск. 594 ГЛАВА 20 Двоичный поиск эффективен, когда метки разбросаны (плотность низкая), как в листинге 20.2 (плотность 0.0008)1 . Поскольку двоичный поиск применим только к отсортированным спискам, компилятор должен предварительно упорядочить метки и начать поиск с медианного значения. В результате порядок блоков case в листинге дизассемблера может отличаться от их порядка в исходном коде2 . switch (a) { /** ПРИМЕЧАНИЕ: тела ветвей case для краткости опущены **/ case 1: /*...*/ break; case 211: /*...*/ break; case 295: /*...*/ break; case 462: /*...*/ break; case 528: /*...*/ break; case 719: /*...*/ break; case 995: /*...*/ break; case 1024: /*...*/ break; case 8000: /*...*/ break; case 13531: /*...*/ break; case 13532: /*...*/ break; case 15027: /*...*/ break; } Листинг 20.2. Пример предложения switch с непоследовательными метками В листинге 20.3 показан набросок неитеративного алгоритма двоичного поиска по фиксированному числу констант. Примерно так компилятор реализует предложение switch из листинга 20.2. 1 Для тех, кто любит на досуге анализировать алгоритмы, объясним: это означает, что для нахождения ветви, соответствующей переменной switch, нужно не более log2N сравнений, где N – число ветвей в предложении switch. Сложность такого алгоритма составляет O(log n). 2 Хотя сложность сортировки очень велика по сравнению со сложностью поиска, важно помнить, что сортировка производится один раз во время компиляции, а поиск – каждый раз, когда во время выполнения встречается switch. ЗависимОсть от кОмПилятОра 595 if (value < median) { // value принадлежит процентилю [0-50) if (value < lower_half_median) { // value принадлежит процентилю [0-25) // ... продолжать деление пополам, пока не будет найдено value } else { // value принадлежит процентилю [25-50) // ... продолжать деление пополам, пока не будет найдено value } } else { // value принадлежит процентилю [50-100) if (value < upper_half_median) { // принадлежит процентилю [50-75) // ... продолжать деление пополам, пока не будет найдено value } else { // принадлежит процентилю [75-100) // ... продолжать деление пополам, пока не будет найдено value } } Листинг 20.3. Неитеративный двоичный поиск по фиксированному числу констант Компиляторы часто могут выполнить более точную оптимизацию в диапазонах значений меток. Например, встретив такой набор меток: label_set = [1, 2, 3, 4, 5, 6, 7, 8, 50, 80, 200, 500, 1000, 5000, 10000] не особенно агрессивный компилятор может заметить, что плотность равна 0.0015, и применить двоичный поиск ко всем 15 случаям. Но более агрессивный компилятор может сгенерировать таблицу переходов для меток 1–8, а к остальным применить двоичный поиск, добившись тем самым оптимальной производительности в более чем половине случаев. Прежде чем рассматривать дизассемблированные версии листингов 20.1 и 20.2, взглянем на окна графов функций для этих листингов, показанные бок о бок на рис. 20.1. 596 ГЛАВА 20 Рис. 20.1. Окна графов функций для примеров предложения switch На левом графе, соответствующем листингу 20.1, мы видим вертикальную стопку блоков case. Глубина вложенности всех блоков одинакова, что естественно для ветвей предложения switch. Структура стопки наводит на мысль, что мы можем быстро выбрать любой блок по индексу (вспомните о доступе к массиву). Именно так работает решение с таблицей переходов, и левый граф визуально подтверждает, что именно оно реализовано, – даже на результат дизассемблирования смотреть не нужно. Правый граф можно понять, только глядя на результат дизассемблирования листинга 20.2. Из-за отсутствия таблицы переходов гораздо труднее идентифицировать здесь предложение switch. То, что мы видим, – это визуальное представление switch с помощью вложенного расположения кода Ghidra. Такое расЗависимОсть от кОмПилятОра 597 положение графов функций применяется в Ghidra по умолчанию и служит для представления структуры потока управления в программе. Горизонтальное ветвление предполагает условное выполнение (if/else) взаимно исключающих альтернатив. Вертикальная симметрия наводит на мысль о том, что альтернативные пути выполнения были тщательно сбалансированы, чтобы в каждой вертикальной половине графа было примерно одинаковое число блоков. Наконец, протяженность графа по горизонтали – индикатор глубины поиска, которая, в свою очередь, определяется общим числом меток case в предложении switch. В случае двоичного поиска эта глубина всегда будет иметь порядок log2(num_cases). Сходство между отступами в графическом представлении и в алгоритме в листинге 20.3 бросается в глаза. Теперь переключимся на окно декомпилятора. На рис. 20.2 показана частичная декомпиляция функций рис. 20.1. Слева – декомпилированная версия листинга 20.1. Как и в случае графа, наличие таблицы переходов в двоичном файле помогает Ghidra распознать предложение switch. Справа показана декомпилированная версия листинга 20.2. Декомпилятор представил предложение switch в виде вложенной конструкции if/else, согласованной с двоичным поиском и структурно похожей на листинг 20.3. Мы видим, что первое сравнение производится со значением 719, медианным в списке, а каждое последующее сравнение делит пространство поиска пополам. Обратившись к рис. 20.1 (а также к листингу 20.3), мы снова замечаем, что графические представления функций очень похожи на структуру отступов в окне декомпилятора. Теперь, понимая, что происходит на верхнем уровне, заглянем внутрь двоичного файла и посмотрим, что там на нижнем уровне. Поскольку в этой главе наша цель – изучить различие между компиляторами, мы представим этот пример как серию сравнений двух компиляторов: gcc и Microsoft C/C++1 . 1 принимает много аргументов в командной строке, и каждый может повлиять на сгенерированный в итоге код. Чтобы с чего-то начать, мы откомпилировали этот пример с такими флагами: . В случае Microsoft C/C++ использовалась немодифицированная отладочная сборка для x86. Дополнительные параметры будут описаны в последующих примерах. 598 ГЛАВА 20 Рис. 20.2. Примеры декомпилированных Ghidra предложений switch Пример: сравнение компиляторов gcc и Microsoft C/C++ В этом примере мы сравним два 32-разрядных двоичных файла для процессора x86, сгенерированных по коду в листинге 20.1 двумя разными компиляторами. Мы попробуем идентифицировать компоненты предложения switch в каждом файле, найти соответствующие таблицы переходов и отметим существенные различия между файлами. Начнем с относящихся к switch компонентам в двоичном файле, созданном gcc. 0001075a CMP  dword ptr [EBP + value],12 0001075e JA switchD_00010771::caseD_0  00010764 MOV EAX,dword ptr [EBP + a] 00010767 SHL EAX,0x2 0001076a ADD EAX,switchD_00010771::switchdataD_00010ee0 = 00010805 0001076f MOV EAX,dword ptr [EAX]=>->switchD_00010771::caseD_0 = 00010805 switchD_00010771::switchD ЗависимОсть от кОмПилятОра 599 00010771 JMP EAX switchD_00010771::caseD_1  XREF[2]: 00010771(j), 00010ee4(*) 00010773 MOV EDX,dword ptr [EBP + a] 00010776 MOV EAX,dword ptr [EBP + b] 00010779 ADD EAX,EDX 0001077b MOV dword ptr [EBP + result],EAX 0001077e JMP switchD_00010771::caseD_0 ;--остальные ветви опущены-- switchD_00010771::switchdataD_00010ee0 XREF[2]: switch_version_1:0001076a(*), switch_version_1:0001076f(R) 00010ee0 addr switchD_00010771::caseD_0  00010ee4 addr switchD_00010771::caseD_1 00010ee8 addr switchD_00010771::caseD_2 00010eec addr switchD_00010771::caseD_3 00010ef0 addr switchD_00010771::caseD_4 00010ef4 addr switchD_00010771::caseD_5 00010ef8 addr switchD_00010771::caseD_6 00010efc addr switchD_00010771::caseD_7 00010f00 addr switchD_00010771::caseD_8 00010f04 addr switchD_00010771::caseD_9 00010f08 addr switchD_00010771::caseD_a 00010f0c addr switchD_00010771::caseD_b 00010f10 addr switchD_00010771::caseD_c Ghidra распознает проверку границ switch , таблицу переходов  и отдельные блоки case по значению, например блок switchD_00010771::caseD_1 . Компилятор сгенерировал таблицу переходов с 13 записями, хотя в листинге 20.1 всего 12 блоков case. Дополнительный блок, case 0 (первая запись  в таблице переходов), разделяет конечный адрес со всеми значениями вне диапазона 1–12. Иными словами, case 0 – часть ветви default. Может показаться, что отрицательные числа не входят в ветвь default, но последовательность команд CMP, JA означает, что сравниваются значения без знака; таким образом, –1 (0xFFFFFFFF) рассматривается как 4294967295, а это значение намного больше 12, поэтому исключается из допустимого диапазона индексов таблицы переходов. Команда JA направляет все такие случаи на ветвь default: switchD_00010771::caseD_0. Поняв, как устроен код, сгенерированный gcc, обратимся к тем же компонентам в коде, сгенерированном компилятором Microsoft C/C++ в отладочном режиме: 600 ГЛАВА 20 00411e88 MOV ECX,dword ptr [EBP + local_d4] 00411e8e SUB  ECX,0x1 00411e91 MOV dword ptr [EBP + local_d4],ECX 00411e97 CMP  dword ptr [EBP + local_d4],11 00411e9e JA switchD_00411eaa::caseD_c 00411ea4 MOV EDX,dword ptr [EBP + local_d4] switchD_00411eaa::switchD 00411eaa JMP dword ptr [EDX*0x4 + ->switchD_00411eaa::caseD = 00411eb1 switchD_00411eaa::caseD_1 XREF[2]: 00411eaa(j), 00411f4c(*) 00411eb1 MOV EAX,dword ptr [EBP + param_1] 00411eb4 ADD EAX,dword ptr [EBP + param_2] 00411eb7 MOV dword ptr [EBP + local_c],EAX 00411eba JMP switchD_00411eaa::caseD_c ;--остальные ветви опущены-- switchD_00411eaa::switchdataD_00411f4c XREF[1]: switch_version_1:00411eaa(R) 00411f4c addr switchD_00411eaa::caseD_1  00411f50 addr switchD_00411eaa::caseD_2 00411f54 addr switchD_00411eaa::caseD_3 00411f58 addr switchD_00411eaa::caseD_4 00411f5c addr switchD_00411eaa::caseD_5 00411f60 addr switchD_00411eaa::caseD_6 00411f64 addr switchD_00411eaa::caseD_7 00411f68 addr switchD_00411eaa::caseD_8 00411f6c addr switchD_00411eaa::caseD_9 00411f70 addr switchD_00411eaa::caseD_a 00411f74 addr switchD_00411eaa::caseD_b 00411f78 addr switchD_00411eaa::caseD_c Здесь переменная switch (в данном случае – local_d4) уменьшается на 1 , чтобы сдвинуть диапазон допустимых значений в 0–11 , устранив тем самым необходимость в фиктивной записи таблицы для значения 0. Поэтому первая запись (с индексом 0) в таблице переходов  на самом деле относится к коду в ветви case 1. Еще одно, более тонкое различие между двумя листингами – местоположение таблицы переходов в файле. Компилятор gcc помещает таблицы переходов switch в секцию постоянных данных (.rodata) двоичного файла, логически отделяя код, связанный с предложением switch, от данных, необходимых для реализации таблицы переходов. А компилятор Microsoft C/ C++ вставляет таблицы переходов в секцию .text, сразу после функции, содержащей код предложения switch. Местоположение таблицы переходов не оказывает никакого влияния на поЗависимОсть от кОмПилятОра 601 ведение программы. В этом примере Ghidra смогла распознать предложения switch, сгенерированные обоими компиляторами, на что указывает употребление слова switch в метках. Важно отметить, что не существует единственного верного способа откомпилировать исходный код на язык ассемблера. Поэтому мы не можем предполагать, что некая конструкция не является предложением switch только потому, что Ghidra не пометила ее как таковое. Понимание характеристик switch, просачивающихся в сгенерированный компилятором код, поможет вам сделать более точные выводы об оригинальном исходном коде. ПАРАМЕТРЫ КОМПИЛЯТОРА Компилятор преобразует высокоуровневый код в эквивалентный низкоуровневый. Разные компиляторы решают одну и ту же задачу по-разному. Кроме того, даже один компилятор может решать задачу по-разному в зависимости от заданных параметров. В этом разделе мы рассмотрим ассемблерный код, генерируемый разными компиляторами при разных параметрах (иногда различия имеют понятные объяснения, а иногда нет). Microsoft Visual Studio может строить отладочную или выпускную версию программы1 . Чтобы понять, чем различаются эти версии, сравним параметры, задаваемые для создания каждой. Выпускная версия обычно оптимизирована, а отладочная нет. С другой стороны, в отладочную версию включается дополнительная информация о символах, и она компонуется с отладочными версиями библиотек2 . Отладочные символы позволяют отладчикам отображать команды языка ассемблера на соответствующий им исходный код и определять имена локальных переменных (в противном случае эта информация в процессе компиляции теряется). Отладочные версии библиотек Microsoft также скомпилированы с включением отладоч1 Другие компиляторы, например gcc, тоже умеют вставлять отладочные символы в сгенерированный код. 2 Оптимизация обычно включает исключение избыточности кода или выбор более быстрых, пусть даже потенциально больших по объему последовательностей команд в зависимости от того, чего хочет разработчик: создать более быструю или меньшую по размеру программу. Анализировать оптимизированный код труднее, чем неоптимизированный, поэтому на этапе разработки и отладки лучше отключать оптимизацию. 602 ГЛАВА 20 ных символов, выключенной оптимизацией и дополнительными проверками правильности параметров. Отладочная сборка проекта Visual Studio, дизассемблированная Ghidra, сильно отличается от выпускной. Это результат параметров компилятора и компоновщика, задаваемых только для отладочной сборки, например флага /RTCx, который вставляет дополнительный код проверки в результирующий двоичный файл1 . Перейдем к рассмотрению некоторых отличий в дизассемблированном коде. Пример 1: оператор деления по модулю Начнем с простой математической операции – деления по модулю. В листинге ниже показан исходный код программы, единственная задача которой – принять целое число от пользователя и продемонстрировать работу оператора деления по модулю. int main(int argc, char **argv) { int x; printf("Введите целое число: "); scanf("%d", &x); printf("%d %% 10 = %d\n", x, x % 10); } Посмотрим, как меняется результат дизассемблирования в зависимости от компилятора и его параметров. Деление по модулю: Microsoft C/C++ Win x64 Debug Ниже показано, какой код генерирует Visual Studio в отладочном режиме: 1400119c6 MOV EAX,dword ptr [RBP + local_f4] 1400119c9 CDQ 1400119ca MOV ECX,0xa 1400119cf IDIV  ECX 1400119d1 MOV EAX,EDX 1400119d3 MOV  R8D,EAX 1400119d6 MOV EDX,dword ptr [RBP + local_f4] 1400119d9 LEA RCX,[s_%d_%%_10_=_%d_140019d60] 1400119e0 CALL printf 1 См. https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks. ЗависимОсть от кОмПилятОра 603 Бесхитростная команда x86 IDIV  оставляет частное в регистре EAX, а остаток от деления в регистре EDX. Затем результат перемещается в младшие 32 бита регистра R8 (R8D) , который передается третьим аргументом функции printf. Деление по модулю: Microsoft C/C++ Win x64 Release В выпускных версиях производится оптимизация быстродействия и размера, чтобы добиться максимальной производительности и уменьшить объем занимаемой памяти. Для оптимизации быстродействия авторы компиляторов прибегают к неочевидным реализациям обычных операций. В листинге ниже показано, как Visual Studio генерирует ту же самую операцию деления по модулю в выпускной сборке. 140001136 MOV ECX,dword ptr [RSP + local_18] 14000113a MOV EAX,0x66666667 14000113f IMUL  ECX 140001141 MOV R8D,ECX 140001144 SAR EDX,0x2 140001147 MOV EAX,EDX 140001149 SHR EAX,0x1f 14000114c ADD EDX,EAX 14000114e LEA EAX,[RDX + RDX*0x4] 140001151 MOV EDX,ECX 140001153 ADD EAX,EAX 140001155 LEA RCX,[s_%d_%%_10_=_%d_140002238] 14000115c SUB  R8D,EAX 14000115f CALL  printf В этом случае используется умножение  вместо деления, и после длинной цепочки арифметических операций нечто, что должно быть результатом деления по модулю, оказывается в регистре R8D  (который, как и раньше, является третьим аргументом printf ). Интуитивно совершенно понятно, правда? Объяснение этого кода мы приведем после следующего примера. Деление по модулю: gcc для Linux x64 Мы видели, как по-разному может вести себя один и тот же компилятор при изменении параметров командной строки. Можно ожидать, что другой компилятор сгенерирует совсем 604 ГЛАВА 20 непохожий код. В листинге ниже показана версия той же операции деления по модулю, сгенерированная gcc, и она не кажется такой уж незнакомой. 00100708 MOV ECX,dword ptr [RBP + x] 0010070b MOV EDX,0x66666667 00100710 MOV EAX,ECX 00100712 IMUL EDX 00100714 SAR EDX,0x2 00100717 MOV EAX,ECX 00100719 SAR EAX,0x1f 0010071c SUB EDX,EAX 0010071e MOV EAX,EDX 00100720 SHL EAX,0x2 00100723 ADD EAX,EDX 00100725 ADD EAX,EAX 00100727 SUB ECX,EAX 00100729 MOV  EDX,ECX Этот код очень похож на сгенерированный Visual Studio в выпускном режиме. Мы снова видим умножение  вместо деления, за которым следует цепочка арифметических операций, оставляющая результат в EDX  (который передается третьим аргументом printf). В этом коде для деления производится умножение на обратное число, потому что оборудование выполняет умножение быстрее, чем деление. Можно видеть, то умножение реализовано в виде последовательности сложений и арифметических сдвигов, потому что каждая из этих операций выполняется намного быстрее умножения. Распознаете ли вы в этом коде деление по модулю 10, зависит от опыта, терпения и творческих способностей. Если вы встречали подобный код раньше, то, вероятно, вам будем проще понять, что здесь происходит. А иначе можно попробовать выполнить код вручную на нескольких значениях в надежде увидеть какую-то закономерность. Можно даже потратить время на то, чтобы вставить этот ассемблерный код в тестовую программу на C и воспользоваться высокоскоростной генерацией тестовых данных. Декомпилятор Ghidra может стать еще одним полезным ресурсом для сведения сложных или необычных последовательностей команды к более знакомым эквивалентам на C. ЗависимОсть от кОмПилятОра 605 В качестве последнего средства (и не надо этого стыдиться) можно поискать ответ в интернете. Но что именно искать? Обычно наиболее релевантные результаты получаются, если задать как можно более специфичный вопрос, а самым специфичным в этом коде является константа 0x66666667. Все три верхних ответа на этот запрос полезны, но особенно заслуживает помещения в закладки документ по адресу http://flaviojslab. blogspot.com/2008/02/integer-division.html. Уникальные константы довольно часто используются в криптографических алгоритмах, и быстрого поиска в интернете может оказаться вполне достаточно, чтобы понять, какая именно криптографическая подпрограмма у нас перед глазами. Пример 2: тернарный оператор Тернарный оператор вычисляет выражение, а затем возвращает один из двух возможных результатов в зависимости от булева значения выражения. Концептуально тернарный оператор можно считать предложением if/else (и даже заменить его таким предложением). В следующем намеренно не оптимизированном исходном коде демонстрируется использование этого оператора: int main() { volatile int x = 3; volatile int y = x * 13;  volatile int z = y == 30 ? 0 : -1; } ПРИМЕЧАНИЕ Ключевое слово volatile просит компилятор не оптимизировать код, в который входят помеченные так переменные. Не будь его, некоторые компиляторы вообще убрали бы все тело функции, потому что ни одно из присутствующих в нем предложений не дает вклада в результат. Это одна из проблем, возникающих при написании примеров кода для себя или для других. Что до поведения неоптимизированного кода, то присваивание переменной z  можно было бы заменить следующим предложением if/else, не изменяя семантики программы: 606 ГЛАВА 20 if (y == 30) { z = 0; } else { z = -1; } Посмотрим, как тернарный оператор обрабатывается различными компиляторами при разных параметрах. Тернарный оператор: gcc для Linux x64 Компилятор gcc без параметров сгенерировал следующий ассемблерный код инициализации z: 00100616 MOV EAX,dword ptr [RBP + y] 00100619 CMP  EAX,0x1e 0010061c JNZ LAB_00100625 0010061e MOV EAX,0x0 00100623 JMP LAB_0010062a LAB_00100625 00100625 MOV EAX,0xffffffff LAB_0010062a 0010062a MOV  dword ptr [RBP + z],EAX Здесь используется реализация в виде if/else. Локальная переменная y сравнивается с 30 , и в зависимости от результата сравнения в регистр EAX записывается 0 или 0xffffffff, а затем этот регистр копируется в z . Тернарный оператор: Microsoft C/C++ Win x64 Release В Visual Studio предложение, содержащее тернарный оператор, компилируется совершенно по-другому. Компилятор понимает, что для условного генерирования значения 0 или -1 (и никаких других) достаточно одной команды, и эта команда используется вместо конструкции if/else: 140001013 MOV EAX,dword ptr [RSP + local_res8] 140001017 SUB EAX,0x1e 14000101a NEG EAX 14000101c SBB EAX,EAX 14000101e MOV dword ptr [RSP + local_res8],EAX ЗависимОсть от кОмПилятОра 607 Команда SBB  (вычитание с заниманием) вычитает второй операнд из первого, а затем еще вычитает флаг переноса CF (который может принимать только значения 0 или 1). Арифметическое выражение, эквивалентное команде SBB EAX,EAX, имеет вид EAX – EAX – CF, что сводится к 0 – CF. Это выражение может быть равно только 0 (если CF == 0) или -1 (если CF == 1). Чтобы этот трюк сработал, компилятор должен правильно установить флаг переноса, перед тем как выполнять команду SBB. Для этого он сравнивает EAX с константой 0x1e (30) , пользуясь операцией вычитания, которая оставляет регистр EAX равным 0, только если первоначально он был равен 0x1e. Затем команда NEG  устанавливает флаг переноса для следующей за ней команды SBB1 . Тернарный оператор: gcc для Linux x64 (с оптимизацией) Когда мы просим gcc поработать чуть усерднее и оптимизировать код (флаг -O2), результат получается похожим на код, сгенерированный Visual Studio в предыдущем примере: 00100506 MOV EAX,dword ptr [RSP + y] 0010050a CMP EAX,0x1e 0010050d SETNZ  AL 00100510 MOVZX EAX,AL 00100513 NEG  EAX 00100515 MOV  dword ptr [RSP + z],EAX В этом случае gcc использует команду SETNZ , чтобы условно записать в регистр AL 0 или 1 в зависимости от состояния флага нуля, установленного в результате предыдущей операции сравнения. Затем результат инвертируется командой NEG и становится равным 0 или -1, после чего присваивается переменной z . Пример 3: встраивание функций Помечая функцию ключевым словом inline, программист предлагает компилятору заменить все вызовы этой функции 1 Команда NEG очищает флаг переноса (CF), если ее операнд равен 0, и устанавливает во всех остальных случаях. 608 ГЛАВА 20 встраиванием ее тела целиком. Идея в том, чтобы ускорить работу функции, устранив накладные расходы на инициализацию и очистку кадра стека. Однако из-за наличия многих копий встраиваемой функции двоичный файл становится больше. Распознать встраиваемые функции в двоичном файле очень трудно, потому что отсутствует отличительный признак функции – команда call. Даже если ключевое слово inline не использовалось, компилятор может встроить функцию по собственной инициативе. В нашем третьем примере мы обращаемся к следующей функции: int maybe_inline() { return 0x12abcdef; } int main() { int v = maybe_inline(); printf("после maybe_inline: v = %08x\n", v);return 0; } Вызов функции: gcc для Linux x86 В результате дизассемблирования двоичного файла, собранного в Linux x86 компилятором gcc без оптимизации, мы получаем такой код: 00010775 PUSH EBP 00010776 MOV EBP,ESP 00010778 PUSH ECX 00010779 SUB ESP,0x14 0001077c CALL maybe_inline 00010781 MOV dword ptr [EBP + local_14],EAX 00010784 SUB ESP,0x8 00010787 PUSH dword ptr [EBP + local_14] 0001078a PUSH s_after_maybe_inline:_v_=_%08x_000108e2 0001078f CALL printf Вызов  функции maybe_inline хорошо виден, хотя это всего одна строка кода, возвращающая константу. ЗависимОсть от кОмПилятОра 609 Вызов функции: gcc для Linux x86 с оптимизацией Теперь посмотрим на оптимизированный (-O2) ассемблерный код того же исходного файла: 0001058a PUSH EBP 0001058b MOV EBP,ESP 0001058d PUSH ECX 0001058e SUB ESP,0x8 00010591 PUSH 0x12abcdef 00010596 PUSH s_after_maybe_inline:_v_=_%08x_000108c2 0001059b PUSH 0x1 0001059d CALL __printf_chk В отличие от неоптимизированной версии, вызов maybe_ inline исключен, а константа , возвращенная maybe_inline, помещается прямо в стек и становится аргументом printf. Эта оптимизированная версия вызова функции совпадает с тем, что мы увидели бы, если бы пометили ее как inline. Рассмотрев, как оптимизация может повлиять на код, сгенерированный компилятором, обратимся к другим способам реализации особенностей языка, которые проектировщики компиляторов выбирают в тех случаях, когда проектировщики языка оставляют детали реализации на усмотрение авторов компилятора. РЕАЛИЗАЦИЯ ЗАВИСЯЩИХ ОТ КОМПИЛЯТОРА ОСОБЕННОСТЕЙ C++ Языки программирования проектируются программистами для программистов. После того как пыль проектирования уляжется, на долю авторов компилятора выпадает построение инструментов, которые верно транслируют программы, написанные на новом языке высокого уровня, в семантически эквивалентные программы на машинном языке. Если язык разрешает программисту делать A, B и C, то автор компилятора должен придумать, как воплотить эти «хотелки» в жизнь. C++ дает три прекрасных примера обязательных свойств языка, детали реализации которых оставлены на усмотрение автора компилятора: 610 ГЛАВА 20 ► внутри нестатической функции-члена класса программист может обращаться к переменной this, которая никогда и нигде не объявляется явно (см. главы 6 и 8 о том, как компиляторы обращаются с this); ► разрешена перегрузка функций. Программист вправе называть разные функции одним и тем же именем при соблюдении определенных ограничений на списки параметров; ► поддерживается интроспекция типа с помощью операторов dynamic_cast и typeid. Перегрузка функций Перегрузка функций в C++ позволяет программисту называть разные функции одним именем, при условии что у них различаются последовательности параметров. Декорирование имен, описанное в главе 8, – это внутренний механизм, благодаря которому перегрузка работает; он гарантирует, что никакие два символа не будут иметь одинаковые имена к тому моменту, как придет черед поработать компоновщику. Зачастую один из первых признаков того, что мы работаем с двоичным файлом программы, написанной на C++, – присутствие декорированных имен. Две самые популярные схемы декорирования имен – Microsoft и Intel Itanium ABI1 .Стандарт Intel широко используется и в других компиляторах для Unix, в частности g++ и clang. Ниже показано имя функции C++ и его декорированный вариант для схем Microsoft и Intel: Функция void SubClass::vfunc1() Схема Microsoft ?vfunc1@SubClass@@UAEXXZ Схема Intel _ZN8SubClass6vfunc1Ev В большинстве языков, допускающих перегрузку, включая Objective-C, Swift и Rust, имеется та или иная форма декорирования имен на уровне реализации. Мимолетное знакомство со стилями декорирования имен может дать ключ к языку, на котором была написана программа, и к компилятору, сгенерировавшему двоичный файл. 1 См. https://docs.microsoft.com/en-us/cpp/build/reference/decorated-names для Microsoft и https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling для Intel. ЗависимОсть от кОмПилятОра 611 Реализации RTTI В главе 8 мы обсуждали механизм идентификации типа во время выполнения (RTTI) в C++, а также отсутствие стандарта реализации RTTI компилятором. На самом деле идентификация типа во время выполнения вообще не упоминается в стандарте C++, поэтому неудивительно, что реализации различаются. Для поддержки оператора dynamic_cast в структурах данных RTTI нужно хранить не только имя класса, но и всю иерархию наследования, в т. ч. множественного. Найти эти структуры данных очень полезно для понимания объектной модели программы. Автоматическое распознавание конструкций, относящихся к RTTI, в двоичном файле – еще одна область, где возможности Ghidra зависят от компилятора. В программах на Microsoft C++ нет встроенной информации о символах, но структуры данных RTTI хорошо понятны, и Ghidra находит их, если они присутствуют. Вся относящаяся к RTTI информация, найденная Ghidra, обобщена в папке Classes дерева символов; для каждого класса, обнаруженного RTTIанализатором, в этой папке содержится по одному элементу. Программы, построенные g++, включают информацию о таблице символов, если файл не был зачищен. Для таких незачищенных двоичных файлов Ghidra полагается исключительно на обнаруженные декорированные имена и ассоциированные с ними классы. Как и в случае двоичных файлов, созданных Microsoft C++, вся относящаяся к RTTI информация включается в папку Classes дерева символов. Чтобы понять, как конкретный компилятор встраивает информацию о типах для классов C++, можно написать простую программу, в которой имеются классы, содержащие виртуальные функции. После компиляции программы получившийся исполняемый файл можно загрузить в Ghidra и поискать строки, содержащие имена используемых классов. Каким бы компилятором ни была создана программа, у структур данных RTTI есть одна общая черта – все они так или иначе ссылаются на строку, 612 ГЛАВА 20 содержащую декорированное имя представляемого ими класса. Используя выделенные строки и перекрестные ссылки на данные, можно найти в двоичном файле потенциальные структуры данных RTTI. Последний шаг – связать кандидата на роль структуры RTTI с vf-таблицей соответствующего класса, следуя по перекрестным ссылкам от структуры в обратную сторону, пока не будет достигнута таблица указателей на функции (искомая vfтаблица). Рассмотрим пример, в котором используется этот метод. Пример: нахождение информации RTTI в двоичном файле, созданном g++ для Linux x86-64 Для демонстрации вышеупомянутых концепций мы создали небольшую программу, содержащую классы BaseClass, SubClass, SubSubClass с виртуальными функциями. В листинге ниже показана часть главной программы, в которой мы ссылаемся на наши классы и функции. BaseClass *bc_ptr_2; srand(time(0)); if (rand() % 2) { bc_ptr_2 = dynamic_cast(new SubClass()); } else { bc_ptr_2 = dynamic_cast(new SubSubClass()); } Мы откомпилировали программу с помощью g++, создав двоичный файл с символами для 64-разрядной версии Linux. После анализа программы дерево символов выглядит, как показано на рис. 20.3. Папка Classes содержит элементы для всех трех классов нашей программы. В раскрытой ветви класса SubClass мы видим дополнительную информацию, добытую Ghidra. В зачищенной версии того же двоичного файла информации будет гораздо меньше, она показана на рис. 20.4. ЗависимОсть от кОмПилятОра 613 Рис. 20.3. Классы в дереве символов незачищенного двоичного файла Рис. 20.4. Классы в дереве символов зачищенного двоичного файла В этом случае мы могли – неправильно – предположить, что двоичный файл вообще не содержит интересных классов C++, хотя программа, скорее всего, написана на C++, о чем говорит ссылка на класс basic_ostream из стандартной библиотеки C++. Поскольку при зачистке удаляется только информация о символах, мы все еще можем найти информацию RTTI, поискав имена классов в строках программы и проложив путь назад к структурам данных RTTI. Поиск по строкам дает результаты, показанные на рис. 20.5. 614 ГЛАВА 20 Рис. 20.5. Поиск по строкам находит имена классов Щелкнув по строке "8SubClass", мы попадем в следующую часть окна листинга: s_8SubClass_00101818 XREF[1]: 00301d20(*) 00101818 ds "8SubClass" В двоичных файлах, созданных g++, структуры, относящиеся к RTTI, содержат ссылку на строку с именем соответствующего класса. Если проследовать по ссылке в первой строке к ее источнику, то мы окажемся в следующей части листинга дизассемблера: PTR___gxx_personality_v0_00301d18 XREF[2]: FUN_00101241:00101316(*), 00301d10(*)  00301d18 addr __gxx_personality_v0 = ??  00301d20 addr s_8SubClass_00101818 = "8SubClass" 00301d28 addr PTR_time_00301d30 = 00303028 Источником перекрестной ссылки  является второе поле в структуре typeinfo класса SubClass, которая начинается по адресу 00301d18 . К сожалению, если вы не готовы копаться в исходном коде g++, то определить формат таких структур можно только экспериментально. Последнее, что осталось сделать, – найти vf-таблицу класса SubClass. В этом примере, если мы последуем по единственной ссылке на структуру typeinfo, берущей начало в области данных  (другая ссылка  исходит из функции и вряд ли может вести на vf-таблицу), то упремся в тупик. Немного математики – и мы узнаем, что перекрестная ЗависимОсть от кОмПилятОра 615 ссылка исходит из адреса, непосредственно предшествующего структуре typeinfo (00301d18 – 8 == 00301d10). При нормальных обстоятельствах должна была бы существовать перекрестная ссылка из vf-таблицы на структуру typeinfo; однако, не располагая символами, Ghidra не может создать эту ссылку. Поскольку мы знаем, что где-то должен быть еще один указатель на нашу структуру typeinfo, мы можем обратиться к Ghidra за помощью. Поместив курсор в начало структуры , мы можем воспользоваться командой меню SearchFor Direct References (ИскатьПрямые ссылки), которая просит Ghidra найти для нас текущий адрес в памяти. Результаты показаны на рис. 20.6. Рис. 20.6. Результаты поиска прямой ссылки Ghidra нашла еще две ссылки на эту структуру typeinfo. Рассмотрев обе, мы, наконец, придем к vf-таблице: 00301c60 ?? 18h ?-> 00301d18 00301c61 ?? 1Dh 00301c62 ?? 30h 0 00301c63 ?? 00h 00301c64 ?? 00h 00301c65 ?? 00h 00301c66 ?? 00h 00301c67 ?? 00h PTR_FUN_00301c68 XREF[2]: FUN_00101098:001010b0(*), FUN_00101098:001010bb(*) 00301c68 addr FUN_001010ea 00301c70 addr FUN_00100ff0 00301c78 addr FUN_00101122 00301c80 addr FUN_00101060 00301c88 addr FUN_0010115a 616 ГЛАВА 20 Ghidra не отформатировала источник  перекрестной ссылки на typeinfoкак указатель (что объясняет отсутствие перекрестной ссылки), но оставила концевой комментарий с предположением, что это может быть указатель . Сама vf-таблица начинается 8 байтами ниже  и содержит пять указателей на виртуальные функции, принадлежащие классу SubClass. В таблице нет декорированных имен, потому что двоичный файл был зачищен. В следующем разделе мы применим эту технику «поиска по хлебным крошкам», чтобы найти функцию main в двоичных файлах, созданных разными компиляторами. НАХОЖДЕНИЕ ФУНКЦИИ MAIN С точки зрения программиста, выполнение программы начинается в функции main, поэтому приступать к анализу программы с этой функции – разумная стратегия. Однако компиляторы и компоновщики (а также библиотеки) добавляют код, выполняемый еще до входа в main. Таким образом, предположение о том, что точка входа в двоичный файл совпадает с функцией main, написанной автором программы, часто оказывается неверным. На самом деле идея о том, что у любой программы есть функция main, – всего лишь соглашение компилятора C/C++, а не непреложное правило написания программ. Если вы когда-нибудь писали приложения с графическим интерфейсом Windows, то, наверное, знакомы с функцией WinMain – вариацией на тему main. А отойдя на шаг в сторону от C/C++, вы столкнетесь с языками, в которых главная точка входа называется совсем иначе. Но мы будем употреблять общее название – «функция main». Если в двоичном файле имеется символ main, то можно просто попросить Ghidra доставить вас туда, однако если файл был зачищен, то Ghidra оставит вас на заголовке файла, и искать main придется самостоятельно. Но, немного понимая, как работает исполняемый файл, и при наличии какого-никакого опыта эта задача не выглядит такой уж пугающей. В любом исполняемом файле должен быть указан адрес первой команды, выполняемой после отображения файла в память. Ghidra называет этот адрес entry или _start в зависимости от типа файла и доступности символов. В большинстве ЗависимОсть от кОмПилятОра 617 форматов исполняемых файлов этот адрес указывается в области заголовка файла, и загрузчики Ghidra точно знают, как его найти. В ELF-файле адрес точки входа хранится в поле e_entry, а в PE-файлах – в поле AddressOfEntryPoint. В откомпилированной C-программе независимо от платформы, для которой она предназначена, по адресу точки входа находится вставленный компилятором код, осуществляющий переход от только что созданного процесса к работающей программе. Частью этого перехода является сбор и передача main (в соответствии с соглашением о вызове) аргументов и переменных окружения, предоставленных процессу ядром в момент создания. ПРИМЕЧАНИЕ Ядро операционной системы знать не знает, на каком языке был написан исполняемый файл. Ядру точно известен единственный способ передачи параметров новому процессу, и этот способ вовсе необязательно совместим с функцией, являющейся точкой входа в программу. Навести мост через эту пропасть – задача компилятора. Зная, что выполнение начинается в опубликованной точке входа и рано или поздно доходит до функции main, мы можем взглянуть на зависящий от компилятора код осуществления этого перехода. Пример 1: от _start к main с компилятором gcc для Linux x86-64 Изучая стартовый код в незачищенном исполняемом файле, мы можем узнать, как достигается main для данной комбинации компилятора и операционной системы. gcc для Linux предлагает довольно простой путь: _start 004003b0 XOR EBP,EBP 004003b2 MOV R9,RDX 004003b5 POP RSI 004003b6 MOV RDX,RSP 004003b9 AND RSP,-0x10 004003bd PUSH RAX 004003be PUSH RSP=>local_10 004003bf MOV R8=>__libc_csu_fini,__libc_csu_fini 618 ГЛАВА 20 004003c6 MOV RCX=>__libc_csu_init,__libc_csu_init 004003cd MOV RDI=>main,main  004003d4 CALL qword ptr [->__libc_start_main] Адрес main загружается в регистр RDI  непосредственно перед вызовом  библиотечной функции __libc_start_main, т. е. адрес main передается первым аргументом __libc_start_main. Вооруженные этим знанием, мы легко найдем main в зачищенном двоичном файле. В следующем листинге показано, как выглядит подготовка к вызову __libc_start_main в зачищенном файле: 004003bf MOV R8=>FUN_004008a0,FUN_004008a0 004003c6 MOV RCX=>FUN_00400830,FUN_00400830 004003cd MOV RDI=>FUN_0040080a,FUN_0040080a 004003d4 CALL qword ptr [->__libc_start_main] Хотя код содержит ссылки на три функции с неконкретизированными именами, мы заключаем, что FUN_0040080a должна быть main, потому что она передается первым аргументом функции __libc_start_main . Пример 2: от _start к main с компилятором clang для FreeBSD x86-64 В современных версиях FreeBSD компилятором C по умолчанию является clang, а функция _start побольше, и протрассировать ее труднее, чем простую вставку _start в Linux. Для простоты воспользуемся декомпилятором Ghidra, чтобы взглянуть на конец _start. // ~40 строк для краткости опущено atexit((__func *)cleanup); handle_static_init(argc,ap,env); argc = main((ulong)pcVar2 & 0xffffffff,ap,env); /* ПРЕДУПРЕЖДЕНИЕ: эта подпрограмма не возвращает управление */ exit(argc); } В данном случае main – предпоследняя функция, вызываемая в _start, а возвращенное ей значение сразу же передается ЗависимОсть от кОмПилятОра 619 функции exit, которая завершает программу. Применение декомпилятора Ghidra к зачищенной версии того же файла дает такой листинг: // ~40 строк для краткости опущено atexit(param_2); FUN_00201120(uVar2 & 0xffffffff,ppcVar5,puVar4); __status = FUN_00201a80(uVar2 & 0xffffffff,ppcVar5,puVar4) ; /* ПРЕДУПРЕЖДЕНИЕ: эта подпрограмма не возвращает управление */ exit(__status); } И снова мы можем выдернуть main  из толпы, хотя двоичный файл и был зачищен. Если вам интересно, почему в листинге присутствуют незачищенные имена двух функций, то это потому, что двоичный файл был скомпонован динамически. Функции atexit и exit – не символы в двоичном файле, а внешние зависимости, которые остаются даже после зачистки и видны в декомпилированном коде. Ниже показан соответствующий код статически скомпонованного зачищенного файла: FUN_0021cc70(); FUN_0021c120(uVar2 & 0xffffffff,ppcVar13,puVar11); uVar7 = FUN_0021caa0(uVar2 & 0xffffffff,ppcVar13,puVar11); /* ПРЕДУПРЕЖДЕНИЕ: эта подпрограмма не возвращает управление */ FUN_00266d30((ulong)uVar7); } Пример 3: от _start к main с компилятором Microsoft’s C/C++ Стартовая вставка, добавляемая компилятором Microsoft C/ C++, несколько сложнее, потому что основной интерфейс сядром Windows осуществляется с помощью библиотеки kernel32.dll (а не libc, как в большинстве Unix-систем), которая не экспортирует никаких библиотечных функций на C. В результате компилятор часто статически включает многие библиотечные функции C прямо в исполняемый файл. Стартовая вставка использует эти и другие функции для интерфейса с ядром на этапе инициализации среды выполнения C-программы. 620 ГЛАВА 20 Но в конце концов вставка все-таки должна вызвать main и завершить процесс после возврата из нее. Поиск main в стартовом коде обычно сводится к идентификации функции с тремя аргументами (main), значение которой передается функции с одним аргументом (exit). Следующий фрагмент двоичного файла этого типа содержит вызовы обеих искомых функций. 140001272 CALL _amsg_exit  140001277 MOV R8,qword ptr [DAT_14000d310] 14000127e MOV qword ptr [DAT_14000d318],R8 140001285 MOV RDX,qword ptr [DAT_14000d300] 14000128c MOV ECX,dword ptr [DAT_14000d2fc] 140001292 CALL FUN_140001060 140001297 MOV EDI,EAX 140001299 MOV dword ptr [RSP + Stack[-0x18]],EAX 14000129d TEST EBX,EBX 14000129f JNZ LAB_1400012a8 1400012a1 MOV ECX,EAX 1400012a3 CALL FUN_140002b30 Здесь FUN_140001060  – функция с тремя аргументами, на самом деле main, а FUN_140002b30  – функция exit с одним аргументом. Заметим, что Ghidra смогла восстановить имя  одной из статически скомпонованных функций, вызываемых из стартовой вставки, поскольку она имеется в базе данных FidDb. Мы можем воспользоваться подсказками в виде идентифицированных символов, чтобы сэкономить немного времени на поиске main. РЕЗЮМЕ Количество зависящих от компилятора особенностей настолько велико, что в одной главе (да и в целой книге, если на то пошло) их не описать. В частности, компиляторы различаются алгоритмами реализации высокоуровневых конструкций и способами оптимизации сгенерированного кода. Поскольку на поведение компилятора сильно влияют аргументы, переданные ему в командной строке, один и тот же компилятор может генерировать совершенно непохожие двоичные файлы из одного исходного. ЗависимОсть от кОмПилятОра 621 К сожалению, свободное владение всеми этими тонкостями приходит только с опытом, и зачастую очень трудно получить помощь по различным конструкциям языка ассемблера и подобрать поисковый запрос, описывающий ваш конкретный случай. Если с вами такое случится, то лучше всего зайти на форум, посвященный обратной разработке, куда вы можете отправить код и получить совет людей, уже сталкивавшихся с подобными проблемами.**


### СТАТИЧЕСКАЯ ДЕОБФУСКАЦИЯ ДВОИЧНЫХ ФАЙЛОВ В GHIDRA




Сейчас, узнав о существующих методах противодействия обратной разработке, вы, наверное, недоумеваете, как вообще возможно проанализировать программу, если автор вознамерился сохранить ее в секрете. Учитывая, что помехи ставятся инструментам и статического, и динамического анализов, какой подход лучше выбрать, чтобы сделать тайное явным? К сожалению, решения, пригодного для всех случаев, не существует. В общем и целом решение зависит от ваших навыков и имеющихся инструментов. Если вы предпочитаете отладчик, то должны будете разработать стратегию обхода мер обнаружения и воспрепятствования работе отладчика. Если же ваш любимый инструмент – дизассемблер, то нужно подумать, как получить верный листинг программы, а если код самомодифицируемый, то как имитировать его поведение, чтобы правильно изменять листинг. В этом разделе мы обсудим два метода обращения с самомодифицируемым кодом при статическом анализе (т. е. без выполнения кода). Статический анализ может оказаться единственным выходом, когда вы не хотите (из-за враждебного кода) или не можете (из-за отсутствия оборудования) проанализировать программу под управлением отладчика. Не отчаивайтесь, если вам кажется, что так вы идете прямиком к кроличьей норе. В Ghidra есть секретное (а может, и не такое уж секретное) оружие, которым можно воспользоваться в битве за статическую деобфускацию. Скриптовая деобфускация Поскольку Ghidra можно использовать для дизассемблирования двоичных файлов, собранных для разных процессоров – и их число постоянно возрастает, – нередко бывает, что анализируется файл, предназначенный совсем не для той платформы, на которой работает Ghidra. Например, вас могут 654 ГЛАВА 21 попросить проанализировать файл для Linux x86, хотя в данный момент вы работаете с Ghidra на macOS. Или проанализировать файл для MIPS или ARM, хотя Ghidra работает на x86. В подобных случаях вам просто недоступны такие инструменты, как отладчики, необходимые для динамического анализа двоичного файла. Если такой файл был обфусцирован путем кодирования участков программы, то нет другого выхода, кроме как создать скрипт Ghidra, который имитирует стадию деобфускации с целью правильно декодировать программу и дизассемблировать декодированные команды и данные. Такая задача поначалу внушает трепет, но во многих случаях при декодировании обфусцированной программы используется только небольшое подмножество системы команд процессора, поэтому изучать все команды, может быть, и не придется. В главе 14 описан алгоритм разработки скриптов, эмулирующих поведение участков программы. В следующем примере мы воспользуемся им для написания простого скрипта Ghidra, который будет декодировать программу, зашифрованную инструментом Burneye ELF Encryption. В нашем примере выполнение начинается командами, показанными в листинге 21.3. 05371035 PUSH dword ptr [DAT_05371008]  0537103b PUSHFD 0537103c PUSHAD 0537103d MOV ECX,dword ptr [DAT_05371000] 05371043 JMP LAB_05371082 ... LAB_05371082 XREF[1]: 05371043(j) 05371082 CALL FUN_05371048 05371087 SHL byte ptr [EBX + -0x2b],1 0537108a PUSHFD 0537108b XCHG byte ptr [EDX + -0x11],AL 0537108e POP SS 0537108f XCHG EAX,ESP 05371090 CWDE 05371091 AAD 0x8e 05371093 PUSH ECX 05371094 OUT DX,EAX 05371095 ADD byte ptr [EDX + 0xa81bee60],BH 0537109b PUSH SS 0537109c RCR dword ptr [ESI + 0xc],CL 0537109f PUSH CS Анализ обфУсцирОваннОго кОда 655 053710a0 SUB AL,0x70 053710a2 CMP CH,byte ptr [EAX + 0x6e] 053710a5 CMP dword ptr [DAT_cbd35372],0x9c38a8bc 053710af AND AL,0xf4 053710b1 SBB EBP,ESP 053710b4 POP DS 053710b5 ?? C6h Листинг 21.3. Начальная последовательность команд Burneye и обфусцированный код Сначала программа помещает в стек содержимое ячейки памяти по адресу 05371008h , а затем флаги процессора  и все регистры . Назначение этих команд не вполне понятно, поэтому мы просто примем их к сведению и разберемся позже. Затем в регистр ECX загружается содержимое ячейки памяти по адресу 05371000h . В соответствии с алгоритмом из главы 14 мы должны в этот момент объявить переменную с именем ECX и инициализировать ее содержимым памяти с помощью функции Ghidra getInt: int ECX = getInt(toAddr(0x5371000)); // из команды по адресу 0537103d После безусловного перехода программа вызывает функцию FUN_05371048 , которая помещает в стек адрес 05371087h (адрес возврата). Дизассемблированные команды, следующие за этим вызовом CALL, становятся все менее и менее осмысленными. Команда OUT  вообще не должна встречаться в пользовательском коде, а команду по адресу 053710B5h  Ghidra не смогла дизассемблировать. Это признаки того, что с двоичным файлом не все в порядке (дополнительным свидетельством является тот факт, что дерево символов содержит всего две функции: entry и FUN_05371048). В этот момент анализ следует продолжить с вызова функции FUN_05371048, показанной в листинге 21.4. FUN_05371048 XREF[1]: entry:05371082(c) 05371048 POP ESI 05371049 MOV EDI,ESI 656 ГЛАВА 21 0537104b MOV EBX,dword ptr [DAT_05371004] = C09657B0h 05371051 OR EBX,EBX 05371053 JZ LAB_0537107f 05371059 XOR EDX,EDX LAB_0537105b XREF[1]: 0537107d(j) 0537105b MOV EAX,0x8 LAB_05371060 XREF[1]: 05371073(j) 05371060 SHRD EDX,EBX,0x1 05371064 SHR EBX,1 05371066 JNC LAB_05371072 0537106c XOR EBX,0xc0000057 LAB_05371072 XREF[1]: 05371066(j) 05371072 DEC EAX 05371073 JNZ LAB_05371060 05371075 SHR EDX,0x18 05371078 LODSB ESI 05371079 XOR AL,DL 0537107b STOSB ES:EDI 0537107c DEC ECX 0537107d JNZ LAB_0537105b LAB_0537107f XREF[1]: 05371053(j) 0537107f POPAD 05371080 POPFD 05371081 RET Листинг 21.4. Функция декодирования из Burneye Это необычная функция: она сразу извлекает адрес возврата из стека в регистр ESI . Напомним, что сохранен был адрес возврата 05371087h, а принимая во внимание инициализацию регистров EDI , EBX  и EDX , мы можем продолжить скрипт следующим образом: int ECX = getInt(toAddr(0x5371000)); // из команды по адресу 0537103D int ESI = 0x05371087; // из команды по адресу 05371048 int EDI = ESI; // из команды по адресу 05371049 int EBX = getInt(toAddr(0x5371004)); // из команды по адресу 0537104B int EDX = 0; // из команды по адресу 05371059 После инициализации функция проверяет значение врегистре EBX , а затем входит во внешний  и во внутренний  циклы. Остальная логика отражена в приведенном ниже полном скрипте. Комментарии соотносят действия скрипта с соответствующими им действиями в листинге дизассемблера выше. Анализ обфУсцирОваннОго кОда 657 public void run() throws Exception { int ECX = getInt(toAddr(0x5371000)); // из команды по адресу 0537103D int ESI = 0x05371087; // из команды по адресу 05371048 int EDI = ESI; // из команды по адресу 05371049 int EBX = getInt(toAddr(0x5371004)); // из команды по адресу 0537104B if (EBX != 0) { // из команды по адресу 05371051 // и 05371053 int EDX = 0; // из команды по адресу 05371059 do { int EAX = 8; // из команды по адресу 0537105B do { // имитировать команду x86 shrd // с помощью нескольких операций EDX = EDX >>> 1; // сдвиг вправо без знака на 1 бит int CF = EBX & 1; // запомнить младший бит EBX if (CF == 1) { // CF представляет флаг переноса x86 EDX = EDX | 0x80000000; // вдвинуть младший бит EBX, если 1 } EBX = EBX >>> 1; // сдвиг вправо без знака на 1 бит if (CF == 1) { // из команды по адресу 05371066 EBX = EBX ^ 0xC0000057; // из команды по адресу 0537106C } EAX--; // из команды по адресу 05371072 } while (EAX != 0); // из команды по адресу 05371073 EDX = EDX >>> 24; // сдвиг вправо без знака на 24 бита  EAX = getByte(toAddr(ESI)); // из команды по адресу 05371078 ESI++; EAX = EAX ^ EDX; // из команды по адресу 05371079 clearListing(toAddr(EDI)); // очистить байт, чтобы можно было // его изменить  setByte(toAddr(EDI), (byte)EAX);// из команды по адресу 0537107B EDI++; ECX--; // из команды по адресу 0537107C } while (ECX != 0); // из команды по адресу 0537107D } } Пытаясь эмулировать какую-нибудь команду, обращайте особое внимание на размеры данных и псевдонимы регистров. В этом примере нам нужно выбрать подходящий размер данных и переменную для правильной реализации команд x86 LODSB (загрузить байт строки) и STOSB (сохранить байт строки). Эти команды записывают (LODSB) и читают (STOSB) младшие 658 ГЛАВА 21 8 бит регистра EAX1 , оставляя старшие 24 бита без изменения. В Java не существует никакого другого способа разбить переменную на битовые участки, кроме как использовать различные поразрядные операции для маскирования и последующего объединения. Конкретно для команды LODSB  корректная эмуляция имела бы такой вид: EAX = (EAX & 0xFFFFFF00) | (getByte(toAddr(ESI)) & 0xFF); Здесь мы сначала очищаем младшие 8 бит переменной EAX, а затем записываем в них другие 8 бит с помощью операции OR. В алгоритме декодирования Burneye в регистр EAX записывается значение 8 в начале каждой итерации внешнего цикла, это эквивалентно обнулению старших 24 битов EAX. Поэтому мы решили упростить реализацию LODSB , проигнорировав запись в старшие 24 бита EAX. Особо задумываться о реализации STOSB  нет нужды, потому что функция setByte требует привести второй аргумент к типу byte. После выполнения скрипта декодирования Burneye результат дизассемблирования будет отражать все изменения, которые в обычной ситуации не были бы видны до выполнения обфусцированной программы в Linux. Если деобфускация произведена правильно, то мы, вероятно, увидим гораздо больше осмысленных строк, воспользовавшись командой поиска SearchFor Strings. Чтобы убедиться в этом, возможно, придется сначала щелкнуть по значку Refresh в окне поиска строк. Осталось (1) определить, куда возвращает управление функция декодирования, учитывая, что она с самого начала извлекла из стека адрес возврата, и (2) убедить Ghidra правильно отобразить декодированные значения байтов как команды или данные. Функция декодирования из Burneye заканчивается такими тремя командами: 0537107f POPAD 05371080 POPFD 05371081 RET 1 Младшие 8 бит регистра EAX называются также регистром AL. Анализ обфУсцирОваннОго кОда 659 Напомним, что функция первым делом извлекла из стека свой адрес возврата, а это означает, что оставшиеся в стеке значения были помещены туда вызывающей стороной. Команды POPAD и POPFD противоположны командам PUSHAD и PUSHFD, выполненным в начале стартовой последовательности Burneye, которую мы еще раз повторяем ниже: entry  05371035 PUSH dword ptr [DAT_05371008] 0537103b PUSHFD 0537103c PUSHAD Стало быть, в стеке осталось только то, что было помещено в первой строке последовательности entry . Это и есть тот адрес, на который передаст управление функция декодирования после возврата, и именно с него мы должны продолжить анализ защищенного двоичного файла. Из рассмотренного примера может сложиться впечатление, будто написать скрипт декодирования или распаковки обфусцированного двоичного файла – относительно несложное дело. Это действительно так в случае инструмента Burneye, в котором не используются особо изощренные алгоритмы обфускации. Деобфускация в Ghidra файлов, упакованных такими хитроумными утилитами, как ASPack или tElock, потребовала бы больше усилий. К преимуществам скриптовой деобфускации можно отнести тот факт, что анализируемый двоичный файл не нужно выполнять и что можно создать работающий скрипт, не понимая до конца все детали алгоритма деобфускации. Последнее утверждение может показаться противоречащим интуиции, поскольку естественно думать, что прежде чем эмулировать алгоритм, в нем необходимо досконально разобраться. Но для применения описанной здесь и в главе 14 процедуры нужно лишь хорошо понимать все команды процессора, участвующие в процессе деобфускации. Если корректно реализовать все операции процессора в Ghidra и правильно расположить их, следуя листингу дизассемблера, то получится скрипт, который имитирует действия программы, даже если вы не понимаете все детали высокоуровневого алгоритма, эти действия содержащего. Но у скриптового подхода есть и недостаток – хрупкость скриптов. Если алгоритм деобфускации изменится в результа660 ГЛАВА 21 те выхода новой версии инструмента или задания других параметров на этапе обфускации файла, то и скрипт тоже придется модифицировать соответственно. Так, можно разработать общие скрипты распаковки двоичных файлов, упакованных UPX, но их придется постоянно править по мере развития UPX. Наконец, скриптовая деобфускация не дает универсального решения. Не существует мегаскрипта, способного деобфусцировать все на свете двоичные файлы. В некотором смысле скриптовая деобфускация страдает теми же недостатками, что антивирусы и системы обнаружения вторжений на основе сигнатур. Новый скрипт приходится разрабатывать для каждого нового типа упаковщиков, а небольшие изменения существующих упаковщиков способны «поломать» имеющиеся скрипты. Давайте теперь рассмотрим более общий подход к деобфускации. Эмуляторная деобфускация При создании скриптов деобфускации вновь и вновь возникает вопрос об эмуляции системы команд процессора, чтобы скрипт вел себя точно так же, как деобфусцируемая программа. Эмуляторы команд позволяют передать эту работу или хотя бы ее часть эмулятору и значительно сократить время, затрачиваемое на деобфускацию в Ghidra. Эмуляторы расположены между скриптами и отладчиками и иногда оказываются более гибкими, чем отладчики. Например, эмулятор может эмулировать команды MIPS на платформе x86 или команды из двоичного ELF-файла для Linux на платформе Windows. Эмуляторы различаются по своим возможностям. Как минимум, эмулятору нужен поток байтов команд и достаточная память для имитации стека и регистров процессора. Более развитые эмуляторы могут предоставлять доступ к эмулируемым аппаратным устройствам и службам операционной системы. Класс Emulator По счастью, Ghidra предлагает развитый класс Emulator, а также EmulatorHelper, который реализует высокоуровневую абстракцию типичной функциональности эмулятора и позволяет быстро и легко создавать скрипты эмуляции. В главе 18 мы познакомились с p-кодом – промежуточным представлением реального ассемблерного кода, – рассказали, как это позволяет Анализ обфУсцирОваннОго кОда 661 декомпилятору работать с разнообразными целевыми архитектурами. Но p-код также поддерживает функциональность эмулятора, а класс ghidra.pcode.emulate.Emulate дает возможность эмулировать одну команду p-кода. Мы можем использовать классы Ghidra для построения эмуляторов широкого круга процессоров. Как и для всех пакетов и классов Ghidra, эта функциональность документирована в формате Javadoc, а для доступа к ней нужно щелкнуть по красному значку плюса в окне диспетчера скриптов. Если вас интересует разработка эмуляторов, то рекомендуем почитать описание методов эмулятора, используемых в следующем примере. Крякни crackme crackme – это задачка, составляемая специалистами по обратной разработке для себе подобных. Название происходит от слова «crack» – взломать (на жаргоне «крякнуть»), – означающего обход ограничений на копирование или использование программы – одно из самых бесчестных применений обратной разработки. Головоломки типа crackme – легальный способ попрактиковаться, а также возможность для автора задачи и человека, который ее анализирует, продемонстрировать свои таланты. Типичная crackme получает данные от пользователя, каким-то образом преобразует их и сравнивает результат преобразования с заранее вычисленным. Желающий решить задачу обычно получает только откомпилированный исполняемый файл, содержащий код преобразования, и результат преобразования неизвестных данных. Задача считается решенной, если удалось вычислить входные данные, на основе которых был сгенерирован результат. Это означает, что вы разобрались в преобразовании настолько хорошо, что можете построить обратную функцию. Пример: SimpleEmulator Пусть имеется двоичный файл, соответствующий описанной ниже задаче crackme, включающий некоторый закодированный участок в начале, который в конечном итоге должен стать телом функции. Мы построим эмуляторный скрипт, который будет автоматизировать процесс декодирования информации, необходимой для решения crackme: 662 ГЛАВА 21  unsigned char check_access[] = { 0xf0, 0xed, 0x2c, 0x40, 0x2c, 0xd8, 0x59, 0x26, 0xd8, 0x59, 0xc1, 0xaa, 0x31, 0x65, 0xaa, 0x13, 0x65, 0xf8, 0x66 }; unsigned char key = 0xa5; void unpack() { for (int ii = 0; ii < sizeof(check_access); ii++) {  check_access[ii] ^= key; } } void do_challenge() { int guess; int access_allowed; int (*check_access_func)(int); unpack(); printf("Введите правильное целое число: "); scanf("%d", &guess); check_access_func = (int (*)(int))check_access; access_allowed = check_access_func(guess); if (access_allowed) { printf("Доступ разрешен!\n"); } else { printf("Доступ запрещен!\n"); } } int main() { do_challenge(); return 0; } Даже при наличии исходного кода для решения этой crackme пришлось бы приложить некоторые усилия из-за наличия закодированного участка . Декомпилятор Ghidra часто оказывается замечательным помощником в решении crackme, но у этой конкретной есть интересные особенности, затрудняющие процесс. Ghidra видит только закодированное тело функции. Во время выполнения функция unpack  декодирует функцию check_access  до ее вызова в точке . Эта crackme обфусцирована, и мы можем написать эмуляторный скрипт Ghidra, который поможет ее решить. В отличие от предыдущего примера, этот эмулятор не просто решит частную задачу, но сможет эмулировать до некоторой степени произвольный код. Анализ обфУсцирОваннОго кОда 663 Шаг 1: поставить задачу Наша задача состоит в том, чтобы спроектировать и разработать простой эмулятор, который позволит выбрать участок листинга дизассемблера и эмулировать содержащиеся в нем команды. Эмулятор нужно будет добавить в Ghidra и сделать доступным в качестве скрипта. Например, если мы выберем функцию unpack в качестве crackme и выполним скрипт, то наш эмулятор должен будет использовать ключ key для распаковки массива check_access и сообщить нам решение задачи. Скрипт запишет байты распакованного кода в память программы в Ghidra. Шаг 2: создать проект скрипта в Eclipse Чтобы создать проект SimpleEmulator, воспользуемся командой GhidraDevNewGhidra Script Project. В результате в Eclipse будет создана папка SimpleEmulator с подпапкой Home scripts (см. рис. 15.16), куда нужно будет поместить новый скрипт. Нам еще нужно создать сам скрипт и ввести метаданные, содержащие документацию и позволяющие каталогизировать скрипт. Метаданные, введенные в диалоговом окне создания скрипта, уже включены в файл, и, как показано на рис. 21.7, нам осталось сделать только одну вещь: Add script code here (Добавить сюда код скрипта). Рис. 21.7. Шаблон скрипта SimpleEmulator 664 ГЛАВА 21 Шаг 3: написать эмулятор Мы знаем, что Eclipse будет подсказывать, что нужно импортировать, по мере разработки, поэтому можем сразу приступить к кодированию и добавлять рекомендованные предложения import, когда Eclipse сочтет необходимым. В классе SimpleEmulator нам понадобятся следующие переменные экземпляра: private EmulatorHelper emuHelper; // объект типа EmulatorHelper private Address executionAddress; // инициализируется началом выбранной области private Address endAddress; // конец выбранной области В комментариях описано назначение переменных. Переменная executionAddress инициализируется начальным адресом выбранной области, а потом продвигается вперед. Шаг 3-1: настроить эмулятор Первое, что нужно сделать в методе скрипта run, – создать объект помощника эмулятора и активировать прослеживание всех операций записи памяти в эмулятор, чтобы измененные значения можно было записать назад в текущую программу. Акт создания объекта играет роль блокировки, аналогичной блокировке, которую браузер кода ставит на открытый двоичный файл. emuHelper = new EmulatorHelper(currentProgram); emuHelper.enableMemoryWriteTracking(true); Шаг 3-2: выбрать подлежащий эмуляции диапазон адресов Поскольку мы хотим, чтобы пользователь сам выбирал подлежащий эмуляции участок кода, нужно проверить, что в окне листинга что-то выбрано. В противном случае мы выдаем сообщение об ошибке. if (currentSelection != null) { executionAddress = currentSelection.getMinAddress(); endAddress = currentSelection.getMaxAddress().next(); } else { println("Ничего не выбрано"); return; } Анализ обфУсцирОваннОго кОда 665 Шаг 3-3: подготовиться к эмуляции Нужно, чтобы в выбранной области указатель executionAddress был направлен на команду, – тогда можно будет определить начальный контекст процессора, инициализировать указатель стека и поставить точку останова в конце выбранной области. Флаг continuing говорит, продолжаем мы эмуляцию или только приступаем к ней, и соответственно определяет, какой вариант метода emuHelper.run вызывается на шаге 3-4. Instruction executionInstr = getInstructionAt(executionAddress); if (executionInstr == null) { printerr("Команда не найдена по адресу: " + executionAddress); return; } long stackOffset = (executionInstr.getAddress().getAddressSpace(). getMaxAddress().getOffset() >>> 1) - 0x7fff; emuHelper.writeRegister(emuHelper.getStackPointerRegister(), stackOffset); // Поставить точку останова на конечном адресе emuHelper.setBreakpoint(endAddress); // Сбросить continuing в false, поскольку мы уже начали эмуляцию boolean continuing = false;; Шаг 3.4: выполнить эмуляцию Дочитав до этого места, вы уже должны узнавать некоторые функции Ghidra API, описанные в главе 14 (например, monitor. isCancelled). Эмуляция производится в цикле, пока не будет выполнено определенное нами условие.  while (!monitor.isCancelled() && !emuHelper.getExecutionAddress().equals(endAddress)) { if (continuing) { emuHelper.run(monitor); } else { emuHelper.run(executionAddress, executionInstr, monitor); }  executionAddress = emuHelper.getExecutionAddress(); // определить, почему остановился эмулятор, и обработать // возможные причины  if (emuHelper.getEmulateExecutionState() == EmulateExecutionState.BREAKPOINT) { 666 ГЛАВА 21 continuing = true; } else if (monitor.isCancelled()) { println("Эмуляция прервана по адресу 0x" + executionAddress); continuing = false; } else { println("Ошибка эмуляции по адресу 0x" + executionAddress + ": " + emuHelper.getLastError()); continuing = false; }  writeBackMemory(); if (!continuing) { break; } } В этом примере эмуляция продолжается, пока не выполнено хотя бы одно из следующих условий: монитор обнаружил, что пользователь прервал работу, достигнут конец выбранной области команд или произошла ошибка . После остановки эмулятора мы должны обновить текущий адрес выполнения , а затем обработать причину остановки . И на последнем шаге мы вызываем метод writeBackMemory() . Шаг 3-5: запись памяти обратно в программу Ниже показана реализация метода writeBackMemory() . Этот эмулятор будет тестироваться на процедуре распаковки, которая в конечном итоге записывает байты в память. Изменения, произведенные эмулятором, существуют только в его рабочей памяти, содержимое которой нужно записать назад в двоичный файл, чтобы изменения, ставшие результатом выполнения команд в процедуре распаковки, были отражены в листинге и других пользовательских интерфейсах. Ghidra предоставляет необходимую для этого функциональность в классе emulatorHelper. private void writeBackMemory() { AddressSetView memWrites = emuHelper.getTrackedMemoryWriteSet(); AddressIterator aIter = memWrites.getAddresses(true); Memory mem = currentProgram.getMemory(); while (aIter.hasNext()) { Address a = aIter.next(); MemoryBlock mb = getMemoryBlock(a); Анализ обфУсцирОваннОго кОда 667 if (mb == null) { continue; } if (!mb.isInitialized()) { // инициализировать память try { mem.convertToInitialized(mb, (byte)0x00); } catch (Exception e) { println(e.toString()); } } try { mem.setByte(a, emuHelper.readMemoryByte(a)); } catch (Exception e) { println(e.toString()); } } } Шаг 3-6: освободить ресурсы На этом шаге мы должны освободить ресурсы и блокировку, поставленную на текущую программу. То и другое делается одним предложением: emuHelper.dispose(); Поскольку этот эмулятор служит только демонстрационным целям, мы позволили себе отнестись к скрипту несколько вольно. Для экономии места мы свели к минимуму комментарии, функциональность, проверку и обработку ошибок – в производственный скрипт все это нужно было бы включить. Осталось убедиться, что наш эмуляторный скрипт решает поставленную задачу. Шаг 4: добавить скрипт в Ghidra Для добавления скрипта в Ghidra нужно лишь поместить его туда, где Ghidra сможет его найти. Если проект скрипта настроен как связанный, то Ghidra уже знает, где искать скрипт. Если же проект не был связан (или если вы создавали скрипт в другом редакторе), то сохраните скрипт в одном из каталогов скриптов Ghidra, как описано в главе 14. 668 ГЛАВА 21 Шаг 5: протестировать скрипт в Ghidra Для тестирования скрипта загрузим двоичный файл, ассоциированный с задачей crackme. Загрузив файл и перейдя к функции unpack, мы заметим, что она содержит ссылку на метку check_access: 0010077d 48 8d 05 8c 08 20 00 LEA RAX,[check_access] Код в окне декомпилятора содержит следующую строку, которая не приближает нас к решению crackme: check_access[(int)local_c] = check_access[(int)local_c] ^ key; Двойной щелчок по check_access в окне листинга перемещает нас по адресу 00301010, но команд, принадлежащих функции, здесь не видно. 00301010 f0 ed 2c 40 2c d8 59 undefined1[19] 26 d8 59 c1 aa 31 65 aa 13 65 f8 66 Если бы мы попробовали дизассемблировать эту область, то Ghidra сообщила бы о плохих данных. Окно декомпилятора тоже ничем не помогает. Что ж, воспользуемся нашим скриптом и посмотрим, удастся ли эмулировать функцию unpack. Выделим команды, составляющие unpack, откроем диспетчер скриптов и запустим наш скрипт. Ни в функции unpack, ни в окне декомпилятора изменений не видно. Но, перейдя к check_access (00301010), мы увидим, что содержимое изменилось! 00301010 55 48 89 e5 89 7d undefined1[19] fc 83 7d fc 64 0f 94 c0 0f b6 c0 5d c3 Мы можем очистить эти байты кода (клавиша C), а затем дизассемблировать (клавиша D). Получится такой результат: Анализ обфУсцирОваннОго кОда 669 check_access 00301010 55 PUSH RBP 00301011 48 89 e5 MOV RBP,RSP 00301014 89 7d fc MOV dword ptr [RBP + -0x4],EDI 00301017 83 7d fc 64 CMP dword ptr [RBP + -0x4],100 0030101b 0f 94 c0 SETZ AL 0030101e 0f b6 c0 MOVZX EAX,AL 00301021 5d POP RBP 00301022 c3 RET А вот как выглядит соответствующий код в окне декомпилятора: ulong UndefinedFunction_00301010(int param_1) { return (ulong)(param_1 == 100); } Это был всего лишь демонстрационный скрипт, доказывающий возможность применения эмуляторов для деобфускации кода, но на его примере мы видим, что с помощью классов поддержки эмуляции, имеющихся в Ghidra, можно написать относительно универсальный эмулятор. Существуют и другие ситуации, когда разработка эмулятора – шаг в правильном направлении. Очевидное преимущество эмуляции по сравнению с отладкой в том, что никакой потенциально вредоносный код не исполняется эмулятором, тогда как при деобфускации с помощью отладчика хотя бы часть вредоносной программы придется выполнить, иначе мы не получим деобфусцированную версию. РЕЗЮМЕ В наши дни обфусцированные вредоносные программы – скорее, правило, а не исключение. Любая попытка изучить внутренние операции вредоноса почти наверняка потребует деобфускации того или иного типа. Какой бы подход ни выбрать – динамический с применением отладчика или не рисковать и остановиться на скриптах либо эмуляции, – конечной целью является получение деобфусцированного двоичного 670 ГЛАВА 21 файла, который можно полностью дизассемблировать и проанализировать. В большинстве случаев для конечного анализа применяются такие инструменты, как Ghidra. Имея в виду эту конечную цель (т. е. использование Ghidra для анализа), разумно попытаться использовать Ghidra на всех этапах – от начала до конца. Методы, описанные в этой главе, призваны продемонстрировать, что Ghidra умеет гораздо больше, чем просто генерировать листинги дизассемблера, а в следующей главе мы воспользуемся полученными знаниями и покажем, как с помощью Ghidra вносить исправления в листинги